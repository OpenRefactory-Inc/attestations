{
    "_type": "https://in-toto.io/Statement/v1",
    "subject": [
        {
            "name": "github.com/numpy/numpy",
            "version": "1.25.0",
            "digest": {
                "sha1": "db4f43983cb938f12c311e1f5b7165e270c393b4"
            }
        }
    ],
    "predicateType": "https://in-toto.io/attestation/openrefactory/v0.1",
    "predicate": [
        {
            "fixerCustomHeading": "Enable HTML Autoescape Mechanism",
            "isWarning": "True",
            "functionName": "render",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/doc/neps/tools/build_index.py",
            "fixerCategoryTag": "PyUSA-16",
            "className": null,
            "priority": "H",
            "scanDate": "Thu Feb 29 08:57:05 UTC 2024",
            "fixerCustomMessageText": "In file: build_index.py, method render HTML Autoescape Mechanism is disabled globally which increases the risk of Cross-Site Scripting (XSS) attacks. iCR suggested that the HTML Autoescape Mechanism should be enabled globally and can be suppressed locally if needed.",
            "fixerCategory": "Security Misconfiguration Issues",
            "selectedNode": "jinja2.Environment(\n        loader=jinja2.FileSystemLoader(path or './'), autoescape=True\n    )",
            "fixNo": "SMI-H-1",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>build_index.py</span>, method <span class='function_name'>render</span> HTML Autoescape Mechanism is disabled globally which increases the risk of Cross-Site Scripting (XSS) attacks. iCR suggested that the HTML Autoescape Mechanism should be enabled globally and can be suppressed locally if needed.",
            "diffLocations": [
                "build_index.py16758580523752584556.diff"
            ]
        },
        {
            "fixerCustomHeading": "Avoid Wildcard Imports",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/numeric.py",
            "fixerCategoryTag": "PyCSI-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:08 UTC 2024",
            "fixerCustomMessageText": "In file: numeric.py, a module is imported using the wildcard symbol. This will import public name from this module and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "import functools\nimport itertools\nimport operator\nimport sys\nimport warnings\nimport numbers\nimport builtins\n\nimport numpy as np\nfrom . import multiarray\nfrom .multiarray import (\n    fastCopyAndTranspose, ALLOW_THREADS,\n    BUFSIZE, CLIP, MAXDIMS, MAY_SHARE_BOUNDS, MAY_SHARE_EXACT, RAISE,\n    WRAP, arange, array, asarray, asanyarray, ascontiguousarray,\n    asfortranarray, broadcast, can_cast, compare_chararrays,\n    concatenate, copyto, dot, dtype, empty,\n    empty_like, flatiter, frombuffer, from_dlpack, fromfile, fromiter,\n    fromstring, inner, lexsort, matmul, may_share_memory,\n    min_scalar_type, ndarray, nditer, nested_iters, promote_types,\n    putmask, result_type, set_numeric_ops, shares_memory, vdot, where,\n    zeros, normalize_axis_index, _get_promotion_state, _set_promotion_state,\n    _using_numpy2_behavior)\n\nfrom . import overrides\nfrom . import umath\nfrom . import shape_base\nfrom .overrides import set_array_function_like_doc, set_module\nfrom .umath import (multiply, invert, sin, PINF, NAN)\nfrom . import numerictypes\nfrom .numerictypes import longlong, intc, int_, float_, complex_, bool_\nfrom ..exceptions import ComplexWarning, TooHardError, AxisError\nfrom ._ufunc_config import errstate, _no_nep50_warning\n\nbitwise_not = invert\nufunc = type(sin)\nnewaxis = None\n\narray_function_dispatch = functools.partial(\n    overrides.array_function_dispatch, module='numpy')\n\n\n__all__ = [\n    'newaxis', 'ndarray', 'flatiter', 'nditer', 'nested_iters', 'ufunc',\n    'arange', 'array', 'asarray', 'asanyarray', 'ascontiguousarray',\n    'asfortranarray', 'zeros', 'count_nonzero', 'empty', 'broadcast', 'dtype',\n    'fromstring', 'fromfile', 'frombuffer', 'from_dlpack', 'where',\n    'argwhere', 'copyto', 'concatenate', 'fastCopyAndTranspose', 'lexsort',\n    'set_numeric_ops', 'can_cast', 'promote_types', 'min_scalar_type',\n    'result_type', 'isfortran', 'empty_like', 'zeros_like', 'ones_like',\n    'correlate', 'convolve', 'inner', 'dot', 'outer', 'vdot', 'roll',\n    'rollaxis', 'moveaxis', 'cross', 'tensordot', 'little_endian',\n    'fromiter', 'array_equal', 'array_equiv', 'indices', 'fromfunction',\n    'isclose', 'isscalar', 'binary_repr', 'base_repr', 'ones',\n    'identity', 'allclose', 'compare_chararrays', 'putmask',\n    'flatnonzero', 'Inf', 'inf', 'infty', 'Infinity', 'nan', 'NaN',\n    'False_', 'True_', 'bitwise_not', 'CLIP', 'RAISE', 'WRAP', 'MAXDIMS',\n    'BUFSIZE', 'ALLOW_THREADS', 'full', 'full_like',\n    'matmul', 'shares_memory', 'may_share_memory', 'MAY_SHARE_BOUNDS',\n    'MAY_SHARE_EXACT', '_get_promotion_state', '_set_promotion_state',\n    '_using_numpy2_behavior']\n\n\ndef _zeros_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):\n    return (a,)\n\n\n@array_function_dispatch(_zeros_like_dispatcher)\ndef zeros_like(a, dtype=None, order='K', subok=True, shape=None):\n    \"\"\"\n    Return an array of zeros with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n\n        .. versionadded:: 1.6.0\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n\n        .. versionadded:: 1.6.0\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of `a`, otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of zeros with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    zeros : Return a new array setting values to zero.\n\n    Examples\n    --------\n    >>> x = np.arange(6)\n    >>> x = x.reshape((2, 3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.zeros_like(x)\n    array([[0, 0, 0],\n           [0, 0, 0]])\n\n    >>> y = np.arange(3, dtype=float)\n    >>> y\n    array([0., 1., 2.])\n    >>> np.zeros_like(y)\n    array([0.,  0.,  0.])\n\n    \"\"\"\n    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)\n    # needed instead of a 0 to get same result as zeros for string dtypes\n    z = zeros(1, dtype=res.dtype)\n    multiarray.copyto(res, z, casting='unsafe')\n    return res\n\n\n@set_array_function_like_doc\n@set_module('numpy')\ndef ones(shape, dtype=None, order='C', *, like=None):\n    \"\"\"\n    Return a new array of given shape and type, filled with ones.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    dtype : data-type, optional\n        The desired data-type for the array, e.g., `numpy.int8`.  Default is\n        `numpy.float64`.\n    order : {'C', 'F'}, optional, default: C\n        Whether to store multi-dimensional data in row-major\n        (C-style) or column-major (Fortran-style) order in\n        memory.\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of ones with the given shape, dtype, and order.\n\n    See Also\n    --------\n    ones_like : Return an array of ones with shape and type of input.\n    empty : Return a new uninitialized array.\n    zeros : Return a new array setting values to zero.\n    full : Return a new array of given shape filled with value.\n\n\n    Examples\n    --------\n    >>> np.ones(5)\n    array([1., 1., 1., 1., 1.])\n\n    >>> np.ones((5,), dtype=int)\n    array([1, 1, 1, 1, 1])\n\n    >>> np.ones((2, 1))\n    array([[1.],\n           [1.]])\n\n    >>> s = (2,2)\n    >>> np.ones(s)\n    array([[1.,  1.],\n           [1.,  1.]])\n\n    \"\"\"\n    if like is not None:\n        return _ones_with_like(like, shape, dtype=dtype, order=order)\n\n    a = empty(shape, dtype, order)\n    multiarray.copyto(a, 1, casting='unsafe')\n    return a\n\n\n_ones_with_like = array_function_dispatch()(ones)\n\n\ndef _ones_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):\n    return (a,)\n\n\n@array_function_dispatch(_ones_like_dispatcher)\ndef ones_like(a, dtype=None, order='K', subok=True, shape=None):\n    \"\"\"\n    Return an array of ones with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n\n        .. versionadded:: 1.6.0\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n\n        .. versionadded:: 1.6.0\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of `a`, otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of ones with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full_like : Return a new array with shape of input filled with value.\n    ones : Return a new array setting values to one.\n\n    Examples\n    --------\n    >>> x = np.arange(6)\n    >>> x = x.reshape((2, 3))\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.ones_like(x)\n    array([[1, 1, 1],\n           [1, 1, 1]])\n\n    >>> y = np.arange(3, dtype=float)\n    >>> y\n    array([0., 1., 2.])\n    >>> np.ones_like(y)\n    array([1.,  1.,  1.])\n\n    \"\"\"\n    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)\n    multiarray.copyto(res, 1, casting='unsafe')\n    return res\n\n\ndef _full_dispatcher(shape, fill_value, dtype=None, order=None, *, like=None):\n    return(like,)\n\n\n@set_array_function_like_doc\n@set_module('numpy')\ndef full(shape, fill_value, dtype=None, order='C', *, like=None):\n    \"\"\"\n    Return a new array of given shape and type, filled with `fill_value`.\n\n    Parameters\n    ----------\n    shape : int or sequence of ints\n        Shape of the new array, e.g., ``(2, 3)`` or ``2``.\n    fill_value : scalar or array_like\n        Fill value.\n    dtype : data-type, optional\n        The desired data-type for the array  The default, None, means\n         ``np.array(fill_value).dtype``.\n    order : {'C', 'F'}, optional\n        Whether to store multidimensional data in C- or Fortran-contiguous\n        (row- or column-wise) order in memory.\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of `fill_value` with the given shape, dtype, and order.\n\n    See Also\n    --------\n    full_like : Return a new array with shape of input filled with value.\n    empty : Return a new uninitialized array.\n    ones : Return a new array setting values to one.\n    zeros : Return a new array setting values to zero.\n\n    Examples\n    --------\n    >>> np.full((2, 2), np.inf)\n    array([[inf, inf],\n           [inf, inf]])\n    >>> np.full((2, 2), 10)\n    array([[10, 10],\n           [10, 10]])\n\n    >>> np.full((2, 2), [1, 2])\n    array([[1, 2],\n           [1, 2]])\n\n    \"\"\"\n    if like is not None:\n        return _full_with_like(\n                like, shape, fill_value, dtype=dtype, order=order)\n\n    if dtype is None:\n        fill_value = asarray(fill_value)\n        dtype = fill_value.dtype\n    a = empty(shape, dtype, order)\n    multiarray.copyto(a, fill_value, casting='unsafe')\n    return a\n\n\n_full_with_like = array_function_dispatch()(full)\n\n\ndef _full_like_dispatcher(a, fill_value, dtype=None, order=None, subok=None, shape=None):\n    return (a,)\n\n\n@array_function_dispatch(_full_like_dispatcher)\ndef full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None):\n    \"\"\"\n    Return a full array with the same shape and type as a given array.\n\n    Parameters\n    ----------\n    a : array_like\n        The shape and data-type of `a` define these same attributes of\n        the returned array.\n    fill_value : array_like\n        Fill value.\n    dtype : data-type, optional\n        Overrides the data type of the result.\n    order : {'C', 'F', 'A', or 'K'}, optional\n        Overrides the memory layout of the result. 'C' means C-order,\n        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,\n        'C' otherwise. 'K' means match the layout of `a` as closely\n        as possible.\n    subok : bool, optional.\n        If True, then the newly created array will use the sub-class\n        type of `a`, otherwise it will be a base-class array. Defaults\n        to True.\n    shape : int or sequence of ints, optional.\n        Overrides the shape of the result. If order='K' and the number of\n        dimensions is unchanged, will try to keep order, otherwise,\n        order='C' is implied.\n\n        .. versionadded:: 1.17.0\n\n    Returns\n    -------\n    out : ndarray\n        Array of `fill_value` with the same shape and type as `a`.\n\n    See Also\n    --------\n    empty_like : Return an empty array with shape and type of input.\n    ones_like : Return an array of ones with shape and type of input.\n    zeros_like : Return an array of zeros with shape and type of input.\n    full : Return a new array of given shape filled with value.\n\n    Examples\n    --------\n    >>> x = np.arange(6, dtype=int)\n    >>> np.full_like(x, 1)\n    array([1, 1, 1, 1, 1, 1])\n    >>> np.full_like(x, 0.1)\n    array([0, 0, 0, 0, 0, 0])\n    >>> np.full_like(x, 0.1, dtype=np.double)\n    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n    >>> np.full_like(x, np.nan, dtype=np.double)\n    array([nan, nan, nan, nan, nan, nan])\n\n    >>> y = np.arange(6, dtype=np.double)\n    >>> np.full_like(y, 0.1)\n    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n\n    >>> y = np.zeros([2, 2, 3], dtype=int)\n    >>> np.full_like(y, [0, 0, 255])\n    array([[[  0,   0, 255],\n            [  0,   0, 255]],\n           [[  0,   0, 255],\n            [  0,   0, 255]]])\n    \"\"\"\n    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)\n    multiarray.copyto(res, fill_value, casting='unsafe')\n    return res\n\n\ndef _count_nonzero_dispatcher(a, axis=None, *, keepdims=None):\n    return (a,)\n\n\n@array_function_dispatch(_count_nonzero_dispatcher)\ndef count_nonzero(a, axis=None, *, keepdims=False):\n    \"\"\"\n    Counts the number of non-zero values in the array ``a``.\n\n    The word \"non-zero\" is in reference to the Python 2.x\n    built-in method ``__nonzero__()`` (renamed ``__bool__()``\n    in Python 3.x) of Python objects that tests an object's\n    \"truthfulness\". For example, any number is considered\n    truthful if it is nonzero, whereas any string is considered\n    truthful if it is not the empty string. Thus, this function\n    (recursively) counts how many elements in ``a`` (and in\n    sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``\n    method evaluated to ``True``.\n\n    Parameters\n    ----------\n    a : array_like\n        The array for which to count non-zeros.\n    axis : int or tuple, optional\n        Axis or tuple of axes along which to count non-zeros.\n        Default is None, meaning that non-zeros will be counted\n        along a flattened version of ``a``.\n\n        .. versionadded:: 1.12.0\n\n    keepdims : bool, optional\n        If this is set to True, the axes that are counted are left\n        in the result as dimensions with size one. With this option,\n        the result will broadcast correctly against the input array.\n\n        .. versionadded:: 1.19.0\n\n    Returns\n    -------\n    count : int or array of int\n        Number of non-zero values in the array along a given axis.\n        Otherwise, the total number of non-zero values in the array\n        is returned.\n\n    See Also\n    --------\n    nonzero : Return the coordinates of all the non-zero values.\n\n    Examples\n    --------\n    >>> np.count_nonzero(np.eye(4))\n    4\n    >>> a = np.array([[0, 1, 7, 0],\n    ...               [3, 0, 2, 19]])\n    >>> np.count_nonzero(a)\n    5\n    >>> np.count_nonzero(a, axis=0)\n    array([1, 1, 2, 1])\n    >>> np.count_nonzero(a, axis=1)\n    array([2, 3])\n    >>> np.count_nonzero(a, axis=1, keepdims=True)\n    array([[2],\n           [3]])\n    \"\"\"\n    if axis is None and not keepdims:\n        return multiarray.count_nonzero(a)\n\n    a = asanyarray(a)\n\n    # TODO: this works around .astype(bool) not working properly (gh-9847)\n    if np.issubdtype(a.dtype, np.character):\n        a_bool = a != a.dtype.type()\n    else:\n        a_bool = a.astype(np.bool_, copy=False)\n\n    return a_bool.sum(axis=axis, dtype=np.intp, keepdims=keepdims)\n\n\n@set_module('numpy')\ndef isfortran(a):\n    \"\"\"\n    Check if the array is Fortran contiguous but *not* C contiguous.\n\n    This function is obsolete and, because of changes due to relaxed stride\n    checking, its return value for the same array may differ for versions\n    of NumPy >= 1.10.0 and previous versions. If you only want to check if an\n    array is Fortran contiguous use ``a.flags.f_contiguous`` instead.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n\n    Returns\n    -------\n    isfortran : bool\n        Returns True if the array is Fortran contiguous but *not* C contiguous.\n\n\n    Examples\n    --------\n\n    np.array allows to specify whether the array is written in C-contiguous\n    order (last index varies the fastest), or FORTRAN-contiguous order in\n    memory (first index varies the fastest).\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n\n    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')\n    >>> b\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(b)\n    True\n\n\n    The transpose of a C-ordered array is a FORTRAN-ordered array.\n\n    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n    >>> a\n    array([[1, 2, 3],\n           [4, 5, 6]])\n    >>> np.isfortran(a)\n    False\n    >>> b = a.T\n    >>> b\n    array([[1, 4],\n           [2, 5],\n           [3, 6]])\n    >>> np.isfortran(b)\n    True\n\n    C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.\n\n    >>> np.isfortran(np.array([1, 2], order='F'))\n    False\n\n    \"\"\"\n    return a.flags.fnc\n\n\ndef _argwhere_dispatcher(a):\n    return (a,)\n\n\n@array_function_dispatch(_argwhere_dispatcher)\ndef argwhere(a):\n    \"\"\"\n    Find the indices of array elements that are non-zero, grouped by element.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    index_array : (N, a.ndim) ndarray\n        Indices of elements that are non-zero. Indices are grouped by element.\n        This array will have shape ``(N, a.ndim)`` where ``N`` is the number of\n        non-zero items.\n\n    See Also\n    --------\n    where, nonzero\n\n    Notes\n    -----\n    ``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,\n    but produces a result of the correct shape for a 0D array.\n\n    The output of ``argwhere`` is not suitable for indexing arrays.\n    For this purpose use ``nonzero(a)`` instead.\n\n    Examples\n    --------\n    >>> x = np.arange(6).reshape(2,3)\n    >>> x\n    array([[0, 1, 2],\n           [3, 4, 5]])\n    >>> np.argwhere(x>1)\n    array([[0, 2],\n           [1, 0],\n           [1, 1],\n           [1, 2]])\n\n    \"\"\"\n    # nonzero does not behave well on 0d, so promote to 1d\n    if np.ndim(a) == 0:\n        a = shape_base.atleast_1d(a)\n        # then remove the added dimension\n        return argwhere(a)[:,:0]\n    return transpose(nonzero(a))\n\n\ndef _flatnonzero_dispatcher(a):\n    return (a,)\n\n\n@array_function_dispatch(_flatnonzero_dispatcher)\ndef flatnonzero(a):\n    \"\"\"\n    Return indices that are non-zero in the flattened version of a.\n\n    This is equivalent to ``np.nonzero(np.ravel(a))[0]``.\n\n    Parameters\n    ----------\n    a : array_like\n        Input data.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, containing the indices of the elements of ``a.ravel()``\n        that are non-zero.\n\n    See Also\n    --------\n    nonzero : Return the indices of the non-zero elements of the input array.\n    ravel : Return a 1-D array containing the elements of the input array.\n\n    Examples\n    --------\n    >>> x = np.arange(-2, 3)\n    >>> x\n    array([-2, -1,  0,  1,  2])\n    >>> np.flatnonzero(x)\n    array([0, 1, 3, 4])\n\n    Use the indices of the non-zero elements as an index array to extract\n    these elements:\n\n    >>> x.ravel()[np.flatnonzero(x)]\n    array([-2, -1,  1,  2])\n\n    \"\"\"\n    return np.nonzero(np.ravel(a))[0]\n\n\ndef _correlate_dispatcher(a, v, mode=None):\n    return (a, v)\n\n\n@array_function_dispatch(_correlate_dispatcher)\ndef correlate(a, v, mode='valid'):\n    r\"\"\"\n    Cross-correlation of two 1-dimensional sequences.\n\n    This function computes the correlation as generally defined in signal\n    processing texts:\n\n    .. math:: c_k = \\sum_n a_{n+k} \\cdot \\overline{v}_n\n\n    with a and v sequences being zero-padded where necessary and\n    :math:`\\overline x` denoting complex conjugation.\n\n    Parameters\n    ----------\n    a, v : array_like\n        Input sequences.\n    mode : {'valid', 'same', 'full'}, optional\n        Refer to the `convolve` docstring.  Note that the default\n        is 'valid', unlike `convolve`, which uses 'full'.\n    old_behavior : bool\n        `old_behavior` was removed in NumPy 1.10. If you need the old\n        behavior, use `multiarray.correlate`.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete cross-correlation of `a` and `v`.\n\n    See Also\n    --------\n    convolve : Discrete, linear convolution of two one-dimensional sequences.\n    multiarray.correlate : Old, no conjugate, version of correlate.\n    scipy.signal.correlate : uses FFT which has superior performance on large arrays.\n\n    Notes\n    -----\n    The definition of correlation above is not unique and sometimes correlation\n    may be defined differently. Another common definition is:\n\n    .. math:: c'_k = \\sum_n a_{n} \\cdot \\overline{v_{n+k}}\n\n    which is related to :math:`c_k` by :math:`c'_k = c_{-k}`.\n\n    `numpy.correlate` may perform slowly in large arrays (i.e. n = 1e5) because it does\n    not use the FFT to compute the convolution; in that case, `scipy.signal.correlate` might\n    be preferable.\n\n\n    Examples\n    --------\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5])\n    array([3.5])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\n    array([2. ,  3.5,  3. ])\n    >>> np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\n    array([0.5,  2. ,  3.5,  3. ,  0. ])\n\n    Using complex sequences:\n\n    >>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')\n    array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])\n\n    Note that you get the time reversed, complex conjugated result\n    (:math:`\\overline{c_{-k}}`) when the two input sequences a and v change\n    places:\n\n    >>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')\n    array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\n\n    \"\"\"\n    return multiarray.correlate2(a, v, mode)\n\n\ndef _convolve_dispatcher(a, v, mode=None):\n    return (a, v)\n\n\n@array_function_dispatch(_convolve_dispatcher)\ndef convolve(a, v, mode='full'):\n    \"\"\"\n    Returns the discrete, linear convolution of two one-dimensional sequences.\n\n    The convolution operator is often seen in signal processing, where it\n    models the effect of a linear time-invariant system on a signal [1]_.  In\n    probability theory, the sum of two independent random variables is\n    distributed according to the convolution of their individual\n    distributions.\n\n    If `v` is longer than `a`, the arrays are swapped before computation.\n\n    Parameters\n    ----------\n    a : (N,) array_like\n        First one-dimensional input array.\n    v : (M,) array_like\n        Second one-dimensional input array.\n    mode : {'full', 'valid', 'same'}, optional\n        'full':\n          By default, mode is 'full'.  This returns the convolution\n          at each point of overlap, with an output shape of (N+M-1,). At\n          the end-points of the convolution, the signals do not overlap\n          completely, and boundary effects may be seen.\n\n        'same':\n          Mode 'same' returns output of length ``max(M, N)``.  Boundary\n          effects are still visible.\n\n        'valid':\n          Mode 'valid' returns output of length\n          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given\n          for points where the signals overlap completely.  Values outside\n          the signal boundary have no effect.\n\n    Returns\n    -------\n    out : ndarray\n        Discrete, linear convolution of `a` and `v`.\n\n    See Also\n    --------\n    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier\n                               Transform.\n    scipy.linalg.toeplitz : Used to construct the convolution operator.\n    polymul : Polynomial multiplication. Same output as convolve, but also\n              accepts poly1d objects as input.\n\n    Notes\n    -----\n    The discrete convolution operation is defined as\n\n    .. math:: (a * v)_n = \\\\sum_{m = -\\\\infty}^{\\\\infty} a_m v_{n - m}\n\n    It can be shown that a convolution :math:`x(t) * y(t)` in time/space\n    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier\n    domain, after appropriate padding (padding is necessary to prevent\n    circular convolution).  Since multiplication is more efficient (faster)\n    than convolution, the function `scipy.signal.fftconvolve` exploits the\n    FFT to calculate the convolution of large data-sets.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Convolution\",\n        https://en.wikipedia.org/wiki/Convolution\n\n    Examples\n    --------\n    Note how the convolution operator flips the second array\n    before \"sliding\" the two across one another:\n\n    >>> np.convolve([1, 2, 3], [0, 1, 0.5])\n    array([0. , 1. , 2.5, 4. , 1.5])\n\n    Only return the middle values of the convolution.\n    Contains boundary effects, where zeros are taken\n    into account:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'same')\n    array([1. ,  2.5,  4. ])\n\n    The two arrays are of the same length, so there\n    is only one position where they completely overlap:\n\n    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')\n    array([2.5])\n\n    \"\"\"\n    a, v = array(a, copy=False, ndmin=1), array(v, copy=False, ndmin=1)\n    if (len(v) > len(a)):\n        a, v = v, a\n    if len(a) == 0:\n        raise ValueError('a cannot be empty')\n    if len(v) == 0:\n        raise ValueError('v cannot be empty')\n    return multiarray.correlate(a, v[::-1], mode)\n\n\ndef _outer_dispatcher(a, b, out=None):\n    return (a, b, out)\n\n\n@array_function_dispatch(_outer_dispatcher)\ndef outer(a, b, out=None):\n    \"\"\"\n    Compute the outer product of two vectors.\n\n    Given two vectors `a` and `b` of length ``M`` and ``N``, repsectively,\n    the outer product [1]_ is::\n\n      [[a_0*b_0  a_0*b_1 ... a_0*b_{N-1} ]\n       [a_1*b_0    .\n       [ ...          .\n       [a_{M-1}*b_0            a_{M-1}*b_{N-1} ]]\n\n    Parameters\n    ----------\n    a : (M,) array_like\n        First input vector.  Input is flattened if\n        not already 1-dimensional.\n    b : (N,) array_like\n        Second input vector.  Input is flattened if\n        not already 1-dimensional.\n    out : (M, N) ndarray, optional\n        A location where the result is stored\n\n        .. versionadded:: 1.9.0\n\n    Returns\n    -------\n    out : (M, N) ndarray\n        ``out[i, j] = a[i] * b[j]``\n\n    See also\n    --------\n    inner\n    einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.\n    ufunc.outer : A generalization to dimensions other than 1D and other\n                  operations. ``np.multiply.outer(a.ravel(), b.ravel())``\n                  is the equivalent.\n    tensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``\n                is the equivalent.\n\n    References\n    ----------\n    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd\n           ed., Baltimore, MD, Johns Hopkins University Press, 1996,\n           pg. 8.\n\n    Examples\n    --------\n    Make a (*very* coarse) grid for computing a Mandelbrot set:\n\n    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n    >>> rl\n    array([[-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.],\n           [-2., -1.,  0.,  1.,  2.]])\n    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n    >>> im\n    array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n           [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n           [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n           [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n           [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n    >>> grid = rl + im\n    >>> grid\n    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n    An example using a \"vector\" of letters:\n\n    >>> x = np.array(['a', 'b', 'c'], dtype=object)\n    >>> np.outer(x, [1, 2, 3])\n    array([['a', 'aa', 'aaa'],\n           ['b', 'bb', 'bbb'],\n           ['c', 'cc', 'ccc']], dtype=object)\n\n    \"\"\"\n    a = asarray(a)\n    b = asarray(b)\n    return multiply(a.ravel()[:, newaxis], b.ravel()[newaxis, :], out)\n\n\ndef _tensordot_dispatcher(a, b, axes=None):\n    return (a, b)\n\n\n@array_function_dispatch(_tensordot_dispatcher)\ndef tensordot(a, b, axes=2):\n    \"\"\"\n    Compute tensor dot product along specified axes.\n\n    Given two tensors, `a` and `b`, and an array_like object containing\n    two array_like objects, ``(a_axes, b_axes)``, sum the products of\n    `a`'s and `b`'s elements (components) over the axes specified by\n    ``a_axes`` and ``b_axes``. The third argument can be a single non-negative\n    integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions\n    of `a` and the first ``N`` dimensions of `b` are summed over.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Tensors to \"dot\".\n\n    axes : int or (2,) array_like\n        * integer_like\n          If an int N, sum over the last N axes of `a` and the first N axes\n          of `b` in order. The sizes of the corresponding axes must match.\n        * (2,) array_like\n          Or, a list of axes to be summed over, first sequence applying to `a`,\n          second to `b`. Both elements array_like must be of the same length.\n\n    Returns\n    -------\n    output : ndarray\n        The tensor dot product of the input.\n\n    See Also\n    --------\n    dot, einsum\n\n    Notes\n    -----\n    Three common use cases are:\n        * ``axes = 0`` : tensor product :math:`a\\\\otimes b`\n        * ``axes = 1`` : tensor dot product :math:`a\\\\cdot b`\n        * ``axes = 2`` : (default) tensor double contraction :math:`a:b`\n\n    When `axes` is integer_like, the sequence for evaluation will be: first\n    the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and\n    Nth axis in `b` last.\n\n    When there is more than one axis to sum over - and they are not the last\n    (first) axes of `a` (`b`) - the argument `axes` should consist of\n    two sequences of the same length, with the first axis to sum over given\n    first in both sequences, the second axis second, and so forth.\n\n    The shape of the result consists of the non-contracted axes of the\n    first tensor, followed by the non-contracted axes of the second.\n\n    Examples\n    --------\n    A \"traditional\" example:\n\n    >>> a = np.arange(60.).reshape(3,4,5)\n    >>> b = np.arange(24.).reshape(4,3,2)\n    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))\n    >>> c.shape\n    (5, 2)\n    >>> c\n    array([[4400., 4730.],\n           [4532., 4874.],\n           [4664., 5018.],\n           [4796., 5162.],\n           [4928., 5306.]])\n    >>> # A slower but equivalent way of computing the same...\n    >>> d = np.zeros((5,2))\n    >>> for i in range(5):\n    ...   for j in range(2):\n    ...     for k in range(3):\n    ...       for n in range(4):\n    ...         d[i,j] += a[k,n,i] * b[n,k,j]\n    >>> c == d\n    array([[ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True],\n           [ True,  True]])\n\n    An extended example taking advantage of the overloading of + and \\\\*:\n\n    >>> a = np.array(range(1, 9))\n    >>> a.shape = (2, 2, 2)\n    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n    >>> A.shape = (2, 2)\n    >>> a; A\n    array([[[1, 2],\n            [3, 4]],\n           [[5, 6],\n            [7, 8]]])\n    array([['a', 'b'],\n           ['c', 'd']], dtype=object)\n\n    >>> np.tensordot(a, A) # third argument default is 2 for double-contraction\n    array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)\n\n    >>> np.tensordot(a, A, 1)\n    array([[['acc', 'bdd'],\n            ['aaacccc', 'bbbdddd']],\n           [['aaaaacccccc', 'bbbbbdddddd'],\n            ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)\n    array([[[[['a', 'b'],\n              ['c', 'd']],\n              ...\n\n    >>> np.tensordot(a, A, (0, 1))\n    array([[['abbbbb', 'cddddd'],\n            ['aabbbbbb', 'ccdddddd']],\n           [['aaabbbbbbb', 'cccddddddd'],\n            ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, (2, 1))\n    array([[['abb', 'cdd'],\n            ['aaabbbb', 'cccdddd']],\n           [['aaaaabbbbbb', 'cccccdddddd'],\n            ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)\n\n    >>> np.tensordot(a, A, ((0, 1), (0, 1)))\n    array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)\n\n    >>> np.tensordot(a, A, ((2, 1), (1, 0)))\n    array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)\n\n    \"\"\"\n    try:\n        iter(axes)\n    except Exception:\n        axes_a = list(range(-axes, 0))\n        axes_b = list(range(0, axes))\n    else:\n        axes_a, axes_b = axes\n    try:\n        na = len(axes_a)\n        axes_a = list(axes_a)\n    except TypeError:\n        axes_a = [axes_a]\n        na = 1\n    try:\n        nb = len(axes_b)\n        axes_b = list(axes_b)\n    except TypeError:\n        axes_b = [axes_b]\n        nb = 1\n\n    a, b = asarray(a), asarray(b)\n    as_ = a.shape\n    nda = a.ndim\n    bs = b.shape\n    ndb = b.ndim\n    equal = True\n    if na != nb:\n        equal = False\n    else:\n        for k in range(na):\n            if as_[axes_a[k]] != bs[axes_b[k]]:\n                equal = False\n                break\n            if axes_a[k] < 0:\n                axes_a[k] += nda\n            if axes_b[k] < 0:\n                axes_b[k] += ndb\n    if not equal:\n        raise ValueError(\"shape-mismatch for sum\")\n\n    # Move the axes to sum over to the end of \"a\"\n    # and to the front of \"b\"\n    notin = [k for k in range(nda) if k not in axes_a]\n    newaxes_a = notin + axes_a\n    N2 = 1\n    for axis in axes_a:\n        N2 *= as_[axis]\n    newshape_a = (int(multiply.reduce([as_[ax] for ax in notin])), N2)\n    olda = [as_[axis] for axis in notin]\n\n    notin = [k for k in range(ndb) if k not in axes_b]\n    newaxes_b = axes_b + notin\n    N2 = 1\n    for axis in axes_b:\n        N2 *= bs[axis]\n    newshape_b = (N2, int(multiply.reduce([bs[ax] for ax in notin])))\n    oldb = [bs[axis] for axis in notin]\n\n    at = a.transpose(newaxes_a).reshape(newshape_a)\n    bt = b.transpose(newaxes_b).reshape(newshape_b)\n    res = dot(at, bt)\n    return res.reshape(olda + oldb)\n\n\ndef _roll_dispatcher(a, shift, axis=None):\n    return (a,)\n\n\n@array_function_dispatch(_roll_dispatcher)\ndef roll(a, shift, axis=None):\n    \"\"\"\n    Roll array elements along a given axis.\n\n    Elements that roll beyond the last position are re-introduced at\n    the first.\n\n    Parameters\n    ----------\n    a : array_like\n        Input array.\n    shift : int or tuple of ints\n        The number of places by which elements are shifted.  If a tuple,\n        then `axis` must be a tuple of the same size, and each of the\n        given axes is shifted by the corresponding number.  If an int\n        while `axis` is a tuple of ints, then the same value is used for\n        all given axes.\n    axis : int or tuple of ints, optional\n        Axis or axes along which elements are shifted.  By default, the\n        array is flattened before shifting, after which the original\n        shape is restored.\n\n    Returns\n    -------\n    res : ndarray\n        Output array, with the same shape as `a`.\n\n    See Also\n    --------\n    rollaxis : Roll the specified axis backwards, until it lies in a\n               given position.\n\n    Notes\n    -----\n    .. versionadded:: 1.12.0\n\n    Supports rolling over multiple dimensions simultaneously.\n\n    Examples\n    --------\n    >>> x = np.arange(10)\n    >>> np.roll(x, 2)\n    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n    >>> np.roll(x, -2)\n    array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\n\n    >>> x2 = np.reshape(x, (2, 5))\n    >>> x2\n    array([[0, 1, 2, 3, 4],\n           [5, 6, 7, 8, 9]])\n    >>> np.roll(x2, 1)\n    array([[9, 0, 1, 2, 3],\n           [4, 5, 6, 7, 8]])\n    >>> np.roll(x2, -1)\n    array([[1, 2, 3, 4, 5],\n           [6, 7, 8, 9, 0]])\n    >>> np.roll(x2, 1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, -1, axis=0)\n    array([[5, 6, 7, 8, 9],\n           [0, 1, 2, 3, 4]])\n    >>> np.roll(x2, 1, axis=1)\n    array([[4, 0, 1, 2, 3],\n           [9, 5, 6, 7, 8]])\n    >>> np.roll(x2, -1, axis=1)\n    array([[1, 2, 3, 4, 0],\n           [6, 7, 8, 9, 5]])\n    >>> np.roll(x2, (1, 1), axis=(1, 0))\n    array([[9, 5, 6, 7, 8],\n           [4, 0, 1, 2, 3]])\n    >>> np.roll(x2, (2, 1), axis=(1, 0))\n    array([[8, 9, 5, 6, 7],\n           [3, 4, 0, 1, 2]])\n\n    \"\"\"\n    a = asanyarray(a)\n    if axis is None:\n        return roll(a.ravel(), shift, 0).reshape(a.shape)\n\n    else:\n        axis = normalize_axis_tuple(axis, a.ndim, allow_duplicate=True)\n        broadcasted = broadcast(shift, axis)\n        if broadcasted.ndim > 1:\n            raise ValueError(\n                \"'shift' and 'axis' should be scalars or 1D sequences\")\n        shifts = {ax: 0 for ax in range(a.ndim)}\n        for sh, ax in broadcasted:\n            shifts[ax] += sh\n\n        rolls = [((slice(None), slice(None)),)] * a.ndim\n        for ax, offset in shifts.items():\n            offset %= a.shape[ax] or 1  # If `a` is empty, nothing matters.\n            if offset:\n                # (original, result), (original, result)\n                rolls[ax] = ((slice(None, -offset), slice(offset, None)),\n                             (slice(-offset, None), slice(None, offset)))\n\n        result = empty_like(a)\n        for indices in itertools.product(*rolls):\n            arr_index, res_index = zip(*indices)\n            result[res_index] = a[arr_index]\n\n        return result\n\n\ndef _rollaxis_dispatcher(a, axis, start=None):\n    return (a,)\n\n\n@array_function_dispatch(_rollaxis_dispatcher)\ndef rollaxis(a, axis, start=0):\n    \"\"\"\n    Roll the specified axis backwards, until it lies in a given position.\n\n    This function continues to be supported for backward compatibility, but you\n    should prefer `moveaxis`. The `moveaxis` function was added in NumPy\n    1.11.\n\n    Parameters\n    ----------\n    a : ndarray\n        Input array.\n    axis : int\n        The axis to be rolled. The positions of the other axes do not\n        change relative to one another.\n    start : int, optional\n        When ``start <= axis``, the axis is rolled back until it lies in\n        this position. When ``start > axis``, the axis is rolled until it\n        lies before this position. The default, 0, results in a \"complete\"\n        roll. The following table describes how negative values of ``start``\n        are interpreted:\n\n        .. table::\n           :align: left\n\n           +-------------------+----------------------+\n           |     ``start``     | Normalized ``start`` |\n           +===================+======================+\n           | ``-(arr.ndim+1)`` | raise ``AxisError``  |\n           +-------------------+----------------------+\n           | ``-arr.ndim``     | 0                    |\n           +-------------------+----------------------+\n           | |vdots|           | |vdots|              |\n           +-------------------+----------------------+\n           | ``-1``            | ``arr.ndim-1``       |\n           +-------------------+----------------------+\n           | ``0``             | ``0``                |\n           +-------------------+----------------------+\n           | |vdots|           | |vdots|              |\n           +-------------------+----------------------+\n           | ``arr.ndim``      | ``arr.ndim``         |\n           +-------------------+----------------------+\n           | ``arr.ndim + 1``  | raise ``AxisError``  |\n           +-------------------+----------------------+\n\n        .. |vdots|   unicode:: U+22EE .. Vertical Ellipsis\n\n    Returns\n    -------\n    res : ndarray\n        For NumPy >= 1.10.0 a view of `a` is always returned. For earlier\n        NumPy versions a view of `a` is returned only if the order of the\n        axes is changed, otherwise the input array is returned.\n\n    See Also\n    --------\n    moveaxis : Move array axes to new positions.\n    roll : Roll the elements of an array by a number of positions along a\n        given axis.\n\n    Examples\n    --------\n    >>> a = np.ones((3,4,5,6))\n    >>> np.rollaxis(a, 3, 1).shape\n    (3, 6, 4, 5)\n    >>> np.rollaxis(a, 2).shape\n    (5, 3, 4, 6)\n    >>> np.rollaxis(a, 1, 4).shape\n    (3, 5, 6, 4)\n\n    \"\"\"\n    n = a.ndim\n    axis = normalize_axis_index(axis, n)\n    if start < 0:\n        start += n\n    msg = \"'%s' arg requires %d <= %s < %d, but %d was passed in\"\n    if not (0 <= start < n + 1):\n        raise AxisError(msg % ('start', -n, 'start', n + 1, start))\n    if axis < start:\n        # it's been removed\n        start -= 1\n    if axis == start:\n        return a[...]\n    axes = list(range(0, n))\n    axes.remove(axis)\n    axes.insert(start, axis)\n    return a.transpose(axes)\n\n\ndef normalize_axis_tuple(axis, ndim, argname=None, allow_duplicate=False):\n    \"\"\"\n    Normalizes an axis argument into a tuple of non-negative integer axes.\n\n    This handles shorthands such as ``1`` and converts them to ``(1,)``,\n    as well as performing the handling of negative indices covered by\n    `normalize_axis_index`.\n\n    By default, this forbids axes from being specified multiple times.\n\n    Used internally by multi-axis-checking logic.\n\n    .. versionadded:: 1.13.0\n\n    Parameters\n    ----------\n    axis : int, iterable of int\n        The un-normalized index or indices of the axis.\n    ndim : int\n        The number of dimensions of the array that `axis` should be normalized\n        against.\n    argname : str, optional\n        A prefix to put before the error message, typically the name of the\n        argument.\n    allow_duplicate : bool, optional\n        If False, the default, disallow an axis from being specified twice.\n\n    Returns\n    -------\n    normalized_axes : tuple of int\n        The normalized axis index, such that `0 <= normalized_axis < ndim`\n\n    Raises\n    ------\n    AxisError\n        If any axis provided is out of range\n    ValueError\n        If an axis is repeated\n\n    See also\n    --------\n    normalize_axis_index : normalizing a single scalar axis\n    \"\"\"\n    # Optimization to speed-up the most common cases.\n    if type(axis) not in (tuple, list):\n        try:\n            axis = [operator.index(axis)]\n        except TypeError:\n            pass\n    # Going via an iterator directly is slower than via list comprehension.\n    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])\n    if not allow_duplicate and len(set(axis)) != len(axis):\n        if argname:\n            raise ValueError('repeated axis in `{}` argument'.format(argname))\n        else:\n            raise ValueError('repeated axis')\n    return axis\n\n\ndef _moveaxis_dispatcher(a, source, destination):\n    return (a,)\n\n\n@array_function_dispatch(_moveaxis_dispatcher)\ndef moveaxis(a, source, destination):\n    \"\"\"\n    Move axes of an array to new positions.\n\n    Other axes remain in their original order.\n\n    .. versionadded:: 1.11.0\n\n    Parameters\n    ----------\n    a : np.ndarray\n        The array whose axes should be reordered.\n    source : int or sequence of int\n        Original positions of the axes to move. These must be unique.\n    destination : int or sequence of int\n        Destination positions for each of the original axes. These must also be\n        unique.\n\n    Returns\n    -------\n    result : np.ndarray\n        Array with moved axes. This array is a view of the input array.\n\n    See Also\n    --------\n    transpose : Permute the dimensions of an array.\n    swapaxes : Interchange two axes of an array.\n\n    Examples\n    --------\n    >>> x = np.zeros((3, 4, 5))\n    >>> np.moveaxis(x, 0, -1).shape\n    (4, 5, 3)\n    >>> np.moveaxis(x, -1, 0).shape\n    (5, 3, 4)\n\n    These all achieve the same result:\n\n    >>> np.transpose(x).shape\n    (5, 4, 3)\n    >>> np.swapaxes(x, 0, -1).shape\n    (5, 4, 3)\n    >>> np.moveaxis(x, [0, 1], [-1, -2]).shape\n    (5, 4, 3)\n    >>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape\n    (5, 4, 3)\n\n    \"\"\"\n    try:\n        # allow duck-array types if they define transpose\n        transpose = a.transpose\n    except AttributeError:\n        a = asarray(a)\n        transpose = a.transpose\n\n    source = normalize_axis_tuple(source, a.ndim, 'source')\n    destination = normalize_axis_tuple(destination, a.ndim, 'destination')\n    if len(source) != len(destination):\n        raise ValueError('`source` and `destination` arguments must have '\n                         'the same number of elements')\n\n    order = [n for n in range(a.ndim) if n not in source]\n\n    for dest, src in sorted(zip(destination, source)):\n        order.insert(dest, src)\n\n    result = transpose(order)\n    return result\n\n\ndef _cross_dispatcher(a, b, axisa=None, axisb=None, axisc=None, axis=None):\n    return (a, b)\n\n\n@array_function_dispatch(_cross_dispatcher)\ndef cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):\n    \"\"\"\n    Return the cross product of two (arrays of) vectors.\n\n    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular\n    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors\n    are defined by the last axis of `a` and `b` by default, and these axes\n    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is\n    2, the third component of the input vector is assumed to be zero and the\n    cross product calculated accordingly.  In cases where both input vectors\n    have dimension 2, the z-component of the cross product is returned.\n\n    Parameters\n    ----------\n    a : array_like\n        Components of the first vector(s).\n    b : array_like\n        Components of the second vector(s).\n    axisa : int, optional\n        Axis of `a` that defines the vector(s).  By default, the last axis.\n    axisb : int, optional\n        Axis of `b` that defines the vector(s).  By default, the last axis.\n    axisc : int, optional\n        Axis of `c` containing the cross product vector(s).  Ignored if\n        both input vectors have dimension 2, as the return is scalar.\n        By default, the last axis.\n    axis : int, optional\n        If defined, the axis of `a`, `b` and `c` that defines the vector(s)\n        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.\n\n    Returns\n    -------\n    c : ndarray\n        Vector cross product(s).\n\n    Raises\n    ------\n    ValueError\n        When the dimension of the vector(s) in `a` and/or `b` does not\n        equal 2 or 3.\n\n    See Also\n    --------\n    inner : Inner product\n    outer : Outer product.\n    ix_ : Construct index arrays.\n\n    Notes\n    -----\n    .. versionadded:: 1.9.0\n\n    Supports full broadcasting of the inputs.\n\n    Examples\n    --------\n    Vector cross-product.\n\n    >>> x = [1, 2, 3]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([-3,  6, -3])\n\n    One vector with dimension 2.\n\n    >>> x = [1, 2]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Equivalently:\n\n    >>> x = [1, 2, 0]\n    >>> y = [4, 5, 6]\n    >>> np.cross(x, y)\n    array([12, -6, -3])\n\n    Both vectors with dimension 2.\n\n    >>> x = [1,2]\n    >>> y = [4,5]\n    >>> np.cross(x, y)\n    array(-3)\n\n    Multiple vector cross-products. Note that the direction of the cross\n    product vector is defined by the *right-hand rule*.\n\n    >>> x = np.array([[1,2,3], [4,5,6]])\n    >>> y = np.array([[4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[-3,  6, -3],\n           [ 3, -6,  3]])\n\n    The orientation of `c` can be changed using the `axisc` keyword.\n\n    >>> np.cross(x, y, axisc=0)\n    array([[-3,  3],\n           [ 6, -6],\n           [-3,  3]])\n\n    Change the vector definition of `x` and `y` using `axisa` and `axisb`.\n\n    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n    >>> np.cross(x, y)\n    array([[ -6,  12,  -6],\n           [  0,   0,   0],\n           [  6, -12,   6]])\n    >>> np.cross(x, y, axisa=0, axisb=0)\n    array([[-24,  48, -24],\n           [-30,  60, -30],\n           [-36,  72, -36]])\n\n    \"\"\"\n    if axis is not None:\n        axisa, axisb, axisc = (axis,) * 3\n    a = asarray(a)\n    b = asarray(b)\n    # Check axisa and axisb are within bounds\n    axisa = normalize_axis_index(axisa, a.ndim, msg_prefix='axisa')\n    axisb = normalize_axis_index(axisb, b.ndim, msg_prefix='axisb')\n\n    # Move working axis to the end of the shape\n    a = moveaxis(a, axisa, -1)\n    b = moveaxis(b, axisb, -1)\n    msg = (\"incompatible dimensions for cross product\\n\"\n           \"(dimension must be 2 or 3)\")\n    if a.shape[-1] not in (2, 3) or b.shape[-1] not in (2, 3):\n        raise ValueError(msg)\n\n    # Create the output array\n    shape = broadcast(a[..., 0], b[..., 0]).shape\n    if a.shape[-1] == 3 or b.shape[-1] == 3:\n        shape += (3,)\n        # Check axisc is within bounds\n        axisc = normalize_axis_index(axisc, len(shape), msg_prefix='axisc')\n    dtype = promote_types(a.dtype, b.dtype)\n    cp = empty(shape, dtype)\n\n    # recast arrays as dtype\n    a = a.astype(dtype)\n    b = b.astype(dtype)\n\n    # create local aliases for readability\n    a0 = a[..., 0]\n    a1 = a[..., 1]\n    if a.shape[-1] == 3:\n        a2 = a[..., 2]\n    b0 = b[..., 0]\n    b1 = b[..., 1]\n    if b.shape[-1] == 3:\n        b2 = b[..., 2]\n    if cp.ndim != 0 and cp.shape[-1] == 3:\n        cp0 = cp[..., 0]\n        cp1 = cp[..., 1]\n        cp2 = cp[..., 2]\n\n    if a.shape[-1] == 2:\n        if b.shape[-1] == 2:\n            # a0 * b1 - a1 * b0\n            multiply(a0, b1, out=cp)\n            cp -= a1 * b0\n            return cp\n        else:\n            assert b.shape[-1] == 3\n            # cp0 = a1 * b2 - 0  (a2 = 0)\n            # cp1 = 0 - a0 * b2  (a2 = 0)\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a1, b2, out=cp0)\n            multiply(a0, b2, out=cp1)\n            negative(cp1, out=cp1)\n            multiply(a0, b1, out=cp2)\n            cp2 -= a1 * b0\n    else:\n        assert a.shape[-1] == 3\n        if b.shape[-1] == 3:\n            # cp0 = a1 * b2 - a2 * b1\n            # cp1 = a2 * b0 - a0 * b2\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a1, b2, out=cp0)\n            tmp = array(a2 * b1)\n            cp0 -= tmp\n            multiply(a2, b0, out=cp1)\n            multiply(a0, b2, out=tmp)\n            cp1 -= tmp\n            multiply(a0, b1, out=cp2)\n            multiply(a1, b0, out=tmp)\n            cp2 -= tmp\n        else:\n            assert b.shape[-1] == 2\n            # cp0 = 0 - a2 * b1  (b2 = 0)\n            # cp1 = a2 * b0 - 0  (b2 = 0)\n            # cp2 = a0 * b1 - a1 * b0\n            multiply(a2, b1, out=cp0)\n            negative(cp0, out=cp0)\n            multiply(a2, b0, out=cp1)\n            multiply(a0, b1, out=cp2)\n            cp2 -= a1 * b0\n\n    return moveaxis(cp, -1, axisc)\n\n\nlittle_endian = (sys.byteorder == 'little')\n\n\n@set_module('numpy')\ndef indices(dimensions, dtype=int, sparse=False):\n    \"\"\"\n    Return an array representing the indices of a grid.\n\n    Compute an array where the subarrays contain index values 0, 1, ...\n    varying only along the corresponding axis.\n\n    Parameters\n    ----------\n    dimensions : sequence of ints\n        The shape of the grid.\n    dtype : dtype, optional\n        Data type of the result.\n    sparse : boolean, optional\n        Return a sparse representation of the grid instead of a dense\n        representation. Default is False.\n\n        .. versionadded:: 1.17\n\n    Returns\n    -------\n    grid : one ndarray or tuple of ndarrays\n        If sparse is False:\n            Returns one array of grid indices,\n            ``grid.shape = (len(dimensions),) + tuple(dimensions)``.\n        If sparse is True:\n            Returns a tuple of arrays, with\n            ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with\n            dimensions[i] in the ith place\n\n    See Also\n    --------\n    mgrid, ogrid, meshgrid\n\n    Notes\n    -----\n    The output shape in the dense case is obtained by prepending the number\n    of dimensions in front of the tuple of dimensions, i.e. if `dimensions`\n    is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is\n    ``(N, r0, ..., rN-1)``.\n\n    The subarrays ``grid[k]`` contains the N-D array of indices along the\n    ``k-th`` axis. Explicitly::\n\n        grid[k, i0, i1, ..., iN-1] = ik\n\n    Examples\n    --------\n    >>> grid = np.indices((2, 3))\n    >>> grid.shape\n    (2, 2, 3)\n    >>> grid[0]        # row indices\n    array([[0, 0, 0],\n           [1, 1, 1]])\n    >>> grid[1]        # column indices\n    array([[0, 1, 2],\n           [0, 1, 2]])\n\n    The indices can be used as an index into an array.\n\n    >>> x = np.arange(20).reshape(5, 4)\n    >>> row, col = np.indices((2, 3))\n    >>> x[row, col]\n    array([[0, 1, 2],\n           [4, 5, 6]])\n\n    Note that it would be more straightforward in the above example to\n    extract the required elements directly with ``x[:2, :3]``.\n\n    If sparse is set to true, the grid will be returned in a sparse\n    representation.\n\n    >>> i, j = np.indices((2, 3), sparse=True)\n    >>> i.shape\n    (2, 1)\n    >>> j.shape\n    (1, 3)\n    >>> i        # row indices\n    array([[0],\n           [1]])\n    >>> j        # column indices\n    array([[0, 1, 2]])\n\n    \"\"\"\n    dimensions = tuple(dimensions)\n    N = len(dimensions)\n    shape = (1,)*N\n    if sparse:\n        res = tuple()\n    else:\n        res = empty((N,)+dimensions, dtype=dtype)\n    for i, dim in enumerate(dimensions):\n        idx = arange(dim, dtype=dtype).reshape(\n            shape[:i] + (dim,) + shape[i+1:]\n        )\n        if sparse:\n            res = res + (idx,)\n        else:\n            res[i] = idx\n    return res\n\n\n@set_array_function_like_doc\n@set_module('numpy')\ndef fromfunction(function, shape, *, dtype=float, like=None, **kwargs):\n    \"\"\"\n    Construct an array by executing a function over each coordinate.\n\n    The resulting array therefore has a value ``fn(x, y, z)`` at\n    coordinate ``(x, y, z)``.\n\n    Parameters\n    ----------\n    function : callable\n        The function is called with N parameters, where N is the rank of\n        `shape`.  Each parameter represents the coordinates of the array\n        varying along a specific axis.  For example, if `shape`\n        were ``(2, 2)``, then the parameters would be\n        ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``\n    shape : (N,) tuple of ints\n        Shape of the output array, which also determines the shape of\n        the coordinate arrays passed to `function`.\n    dtype : data-type, optional\n        Data-type of the coordinate arrays passed to `function`.\n        By default, `dtype` is float.\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    fromfunction : any\n        The result of the call to `function` is passed back directly.\n        Therefore the shape of `fromfunction` is completely determined by\n        `function`.  If `function` returns a scalar value, the shape of\n        `fromfunction` would not match the `shape` parameter.\n\n    See Also\n    --------\n    indices, meshgrid\n\n    Notes\n    -----\n    Keywords other than `dtype` and `like` are passed to `function`.\n\n    Examples\n    --------\n    >>> np.fromfunction(lambda i, j: i, (2, 2), dtype=float)\n    array([[0., 0.],\n           [1., 1.]])\n\n    >>> np.fromfunction(lambda i, j: j, (2, 2), dtype=float)\n    array([[0., 1.],\n           [0., 1.]])\n\n    >>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\n    array([[ True, False, False],\n           [False,  True, False],\n           [False, False,  True]])\n\n    >>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\n    array([[0, 1, 2],\n           [1, 2, 3],\n           [2, 3, 4]])\n\n    \"\"\"\n    if like is not None:\n        return _fromfunction_with_like(\n                like, function, shape, dtype=dtype, **kwargs)\n\n    args = indices(shape, dtype=dtype)\n    return function(*args, **kwargs)\n\n\n_fromfunction_with_like = array_function_dispatch()(fromfunction)\n\n\ndef _frombuffer(buf, dtype, shape, order):\n    return frombuffer(buf, dtype=dtype).reshape(shape, order=order)\n\n\n@set_module('numpy')\ndef isscalar(element):\n    \"\"\"\n    Returns True if the type of `element` is a scalar type.\n\n    Parameters\n    ----------\n    element : any\n        Input argument, can be of any type and shape.\n\n    Returns\n    -------\n    val : bool\n        True if `element` is a scalar type, False if it is not.\n\n    See Also\n    --------\n    ndim : Get the number of dimensions of an array\n\n    Notes\n    -----\n    If you need a stricter way to identify a *numerical* scalar, use\n    ``isinstance(x, numbers.Number)``, as that returns ``False`` for most\n    non-numerical elements such as strings.\n\n    In most cases ``np.ndim(x) == 0`` should be used instead of this function,\n    as that will also return true for 0d arrays. This is how numpy overloads\n    functions in the style of the ``dx`` arguments to `gradient` and the ``bins``\n    argument to `histogram`. Some key differences:\n\n    +--------------------------------------+---------------+-------------------+\n    | x                                    |``isscalar(x)``|``np.ndim(x) == 0``|\n    +======================================+===============+===================+\n    | PEP 3141 numeric objects (including  | ``True``      | ``True``          |\n    | builtins)                            |               |                   |\n    +--------------------------------------+---------------+-------------------+\n    | builtin string and buffer objects    | ``True``      | ``True``          |\n    +--------------------------------------+---------------+-------------------+\n    | other builtin objects, like          | ``False``     | ``True``          |\n    | `pathlib.Path`, `Exception`,         |               |                   |\n    | the result of `re.compile`           |               |                   |\n    +--------------------------------------+---------------+-------------------+\n    | third-party objects like             | ``False``     | ``True``          |\n    | `matplotlib.figure.Figure`           |               |                   |\n    +--------------------------------------+---------------+-------------------+\n    | zero-dimensional numpy arrays        | ``False``     | ``True``          |\n    +--------------------------------------+---------------+-------------------+\n    | other numpy arrays                   | ``False``     | ``False``         |\n    +--------------------------------------+---------------+-------------------+\n    | `list`, `tuple`, and other sequence  | ``False``     | ``False``         |\n    | objects                              |               |                   |\n    +--------------------------------------+---------------+-------------------+\n\n    Examples\n    --------\n    >>> np.isscalar(3.1)\n    True\n    >>> np.isscalar(np.array(3.1))\n    False\n    >>> np.isscalar([3.1])\n    False\n    >>> np.isscalar(False)\n    True\n    >>> np.isscalar('numpy')\n    True\n\n    NumPy supports PEP 3141 numbers:\n\n    >>> from fractions import Fraction\n    >>> np.isscalar(Fraction(5, 17))\n    True\n    >>> from numbers import Number\n    >>> np.isscalar(Number())\n    True\n\n    \"\"\"\n    return (isinstance(element, generic)\n            or type(element) in ScalarType\n            or isinstance(element, numbers.Number))\n\n\n@set_module('numpy')\ndef binary_repr(num, width=None):\n    \"\"\"\n    Return the binary representation of the input number as a string.\n\n    For negative numbers, if width is not given, a minus sign is added to the\n    front. If width is given, the two's complement of the number is\n    returned, with respect to that width.\n\n    In a two's-complement system negative numbers are represented by the two's\n    complement of the absolute value. This is the most common method of\n    representing signed integers on computers [1]_. A N-bit two's-complement\n    system can represent every integer in the range\n    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.\n\n    Parameters\n    ----------\n    num : int\n        Only an integer decimal number can be used.\n    width : int, optional\n        The length of the returned string if `num` is positive, or the length\n        of the two's complement if `num` is negative, provided that `width` is\n        at least a sufficient number of bits for `num` to be represented in the\n        designated form.\n\n        If the `width` value is insufficient, it will be ignored, and `num` will\n        be returned in binary (`num` > 0) or two's complement (`num` < 0) form\n        with its width equal to the minimum number of bits needed to represent\n        the number in the designated form. This behavior is deprecated and will\n        later raise an error.\n\n        .. deprecated:: 1.12.0\n\n    Returns\n    -------\n    bin : str\n        Binary representation of `num` or two's complement of `num`.\n\n    See Also\n    --------\n    base_repr: Return a string representation of a number in the given base\n               system.\n    bin: Python's built-in binary representation generator of an integer.\n\n    Notes\n    -----\n    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x\n    faster.\n\n    References\n    ----------\n    .. [1] Wikipedia, \"Two's complement\",\n        https://en.wikipedia.org/wiki/Two's_complement\n\n    Examples\n    --------\n    >>> np.binary_repr(3)\n    '11'\n    >>> np.binary_repr(-3)\n    '-11'\n    >>> np.binary_repr(3, width=4)\n    '0011'\n\n    The two's complement is returned when the input number is negative and\n    width is specified:\n\n    >>> np.binary_repr(-3, width=3)\n    '101'\n    >>> np.binary_repr(-3, width=5)\n    '11101'\n\n    \"\"\"\n    def warn_if_insufficient(width, binwidth):\n        if width is not None and width < binwidth:\n            warnings.warn(\n                \"Insufficient bit width provided. This behavior \"\n                \"will raise an error in the future.\", DeprecationWarning,\n                stacklevel=3)\n\n    # Ensure that num is a Python integer to avoid overflow or unwanted\n    # casts to floating point.\n    num = operator.index(num)\n\n    if num == 0:\n        return '0' * (width or 1)\n\n    elif num > 0:\n        binary = bin(num)[2:]\n        binwidth = len(binary)\n        outwidth = (binwidth if width is None\n                    else builtins.max(binwidth, width))\n        warn_if_insufficient(width, binwidth)\n        return binary.zfill(outwidth)\n\n    else:\n        if width is None:\n            return '-' + bin(-num)[2:]\n\n        else:\n            poswidth = len(bin(-num)[2:])\n\n            # See gh-8679: remove extra digit\n            # for numbers at boundaries.\n            if 2**(poswidth - 1) == -num:\n                poswidth -= 1\n\n            twocomp = 2**(poswidth + 1) + num\n            binary = bin(twocomp)[2:]\n            binwidth = len(binary)\n\n            outwidth = builtins.max(binwidth, width)\n            warn_if_insufficient(width, binwidth)\n            return '1' * (outwidth - binwidth) + binary\n\n\n@set_module('numpy')\ndef base_repr(number, base=2, padding=0):\n    \"\"\"\n    Return a string representation of a number in the given base system.\n\n    Parameters\n    ----------\n    number : int\n        The value to convert. Positive and negative values are handled.\n    base : int, optional\n        Convert `number` to the `base` number system. The valid range is 2-36,\n        the default value is 2.\n    padding : int, optional\n        Number of zeros padded on the left. Default is 0 (no padding).\n\n    Returns\n    -------\n    out : str\n        String representation of `number` in `base` system.\n\n    See Also\n    --------\n    binary_repr : Faster version of `base_repr` for base 2.\n\n    Examples\n    --------\n    >>> np.base_repr(5)\n    '101'\n    >>> np.base_repr(6, 5)\n    '11'\n    >>> np.base_repr(7, base=5, padding=3)\n    '00012'\n\n    >>> np.base_repr(10, base=16)\n    'A'\n    >>> np.base_repr(32, base=16)\n    '20'\n\n    \"\"\"\n    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    if base > len(digits):\n        raise ValueError(\"Bases greater than 36 not handled in base_repr.\")\n    elif base < 2:\n        raise ValueError(\"Bases less than 2 not handled in base_repr.\")\n\n    num = abs(number)\n    res = []\n    while num:\n        res.append(digits[num % base])\n        num //= base\n    if padding:\n        res.append('0' * padding)\n    if number < 0:\n        res.append('-')\n    return ''.join(reversed(res or '0'))\n\n\n# These are all essentially abbreviations\n# These might wind up in a special abbreviations module\n\n\ndef _maketup(descr, val):\n    dt = dtype(descr)\n    # Place val in all scalar tuples:\n    fields = dt.fields\n    if fields is None:\n        return val\n    else:\n        res = [_maketup(fields[name][0], val) for name in dt.names]\n        return tuple(res)\n\n\n@set_array_function_like_doc\n@set_module('numpy')\ndef identity(n, dtype=None, *, like=None):\n    \"\"\"\n    Return the identity array.\n\n    The identity array is a square array with ones on\n    the main diagonal.\n\n    Parameters\n    ----------\n    n : int\n        Number of rows (and columns) in `n` x `n` output.\n    dtype : data-type, optional\n        Data-type of the output.  Defaults to ``float``.\n    ${ARRAY_FUNCTION_LIKE}\n\n        .. versionadded:: 1.20.0\n\n    Returns\n    -------\n    out : ndarray\n        `n` x `n` array with its main diagonal set to one,\n        and all other elements 0.\n\n    Examples\n    --------\n    >>> np.identity(3)\n    array([[1.,  0.,  0.],\n           [0.,  1.,  0.],\n           [0.,  0.,  1.]])\n\n    \"\"\"\n    if like is not None:\n        return _identity_with_like(like, n, dtype=dtype)\n\n    from numpy import eye\n    return eye(n, dtype=dtype, like=like)\n\n\n_identity_with_like = array_function_dispatch()(identity)\n\n\ndef _allclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):\n    return (a, b)\n\n\n@array_function_dispatch(_allclose_dispatcher)\ndef allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns True if two arrays are element-wise equal within a tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    NaNs are treated as equal if they are in the same place and if\n    ``equal_nan=True``.  Infs are treated as equal if they are in the same\n    place and of the same sign in both arrays.\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n        .. versionadded:: 1.10.0\n\n    Returns\n    -------\n    allclose : bool\n        Returns True if the two arrays are equal within the given\n        tolerance; False otherwise.\n\n    See Also\n    --------\n    isclose, all, any, equal\n\n    Notes\n    -----\n    If the following equation is element-wise True, then allclose returns\n    True.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    The above equation is not symmetric in `a` and `b`, so that\n    ``allclose(a, b)`` might be different from ``allclose(b, a)`` in\n    some rare cases.\n\n    The comparison of `a` and `b` uses standard broadcasting, which\n    means that `a` and `b` need not have the same shape in order for\n    ``allclose(a, b)`` to evaluate to True.  The same is true for\n    `equal` but not `array_equal`.\n\n    `allclose` is not defined for non-numeric data types.\n    `bool` is considered a numeric data-type for this purpose.\n\n    Examples\n    --------\n    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])\n    False\n    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])\n    True\n    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan])\n    False\n    >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    True\n\n    \"\"\"\n    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))\n    return bool(res)\n\n\ndef _isclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):\n    return (a, b)\n\n\n@array_function_dispatch(_isclose_dispatcher)\ndef isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):\n    \"\"\"\n    Returns a boolean array where two arrays are element-wise equal within a\n    tolerance.\n\n    The tolerance values are positive, typically very small numbers.  The\n    relative difference (`rtol` * abs(`b`)) and the absolute difference\n    `atol` are added together to compare against the absolute difference\n    between `a` and `b`.\n\n    .. warning:: The default `atol` is not appropriate for comparing numbers\n                 that are much smaller than one (see Notes).\n\n    Parameters\n    ----------\n    a, b : array_like\n        Input arrays to compare.\n    rtol : float\n        The relative tolerance parameter (see Notes).\n    atol : float\n        The absolute tolerance parameter (see Notes).\n    equal_nan : bool\n        Whether to compare NaN's as equal.  If True, NaN's in `a` will be\n        considered equal to NaN's in `b` in the output array.\n\n    Returns\n    -------\n    y : array_like\n        Returns a boolean array of where `a` and `b` are equal within the\n        given tolerance. If both `a` and `b` are scalars, returns a single\n        boolean value.\n\n    See Also\n    --------\n    allclose\n    math.isclose\n\n    Notes\n    -----\n    .. versionadded:: 1.7.0\n\n    For finite values, isclose uses the following equation to test whether\n    two floating point values are equivalent.\n\n     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))\n\n    Unlike the built-in `math.isclose`, the above equation is not symmetric\n    in `a` and `b` -- it assumes `b` is the reference value -- so that\n    `isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,\n    the default value of atol is not zero, and is used to determine what\n    small values should be considered close to zero. The default value is\n    appropriate for expected values of order unity: if the expected values\n    are significantly smaller than one, it can result in false positives.\n    `atol` should be carefully selected for the use case at hand. A zero value\n    for `atol` will result in `False` if either `a` or `b` is zero.\n\n    `isclose` is not defined for non-numeric data types.\n    `bool` is considered a numeric data-type for this purpose.\n\n    Examples\n    --------\n    >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])\n    array([ True, False])\n    >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])\n    array([ True, True])\n    >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])\n    array([False,  True])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan])\n    array([ True, False])\n    >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\n    array([ True, True])\n    >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])\n    array([ True, False])\n    >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\n    array([False, False])\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])\n    array([ True,  True])\n    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\n    array([False,  True])\n    \"\"\"\n    def within_tol(x, y, atol, rtol):\n        with errstate(invalid='ignore'), _no_nep50_warning():\n            return less_equal(abs(x-y), atol + rtol * abs(y))\n\n    x = asanyarray(a)\n    y = asanyarray(b)\n\n    # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).\n    # This will cause casting of x later. Also, make sure to allow subclasses\n    # (e.g., for numpy.ma).\n    # NOTE: We explicitly allow timedelta, which used to work. This could\n    #       possibly be deprecated. See also gh-18286.\n    #       timedelta works if `atol` is an integer or also a timedelta.\n    #       Although, the default tolerances are unlikely to be useful\n    if y.dtype.kind != \"m\":\n        dt = multiarray.result_type(y, 1.)\n        y = asanyarray(y, dtype=dt)\n\n    xfin = isfinite(x)\n    yfin = isfinite(y)\n    if all(xfin) and all(yfin):\n        return within_tol(x, y, atol, rtol)\n    else:\n        finite = xfin & yfin\n        cond = zeros_like(finite, subok=True)\n        # Because we're using boolean indexing, x & y must be the same shape.\n        # Ideally, we'd just do x, y = broadcast_arrays(x, y). It's in\n        # lib.stride_tricks, though, so we can't import it here.\n        x = x * ones_like(cond)\n        y = y * ones_like(cond)\n        # Avoid subtraction with infinite/nan values...\n        cond[finite] = within_tol(x[finite], y[finite], atol, rtol)\n        # Check for equality of infinite values...\n        cond[~finite] = (x[~finite] == y[~finite])\n        if equal_nan:\n            # Make NaN == NaN\n            both_nan = isnan(x) & isnan(y)\n\n            # Needed to treat masked arrays correctly. = True would not work.\n            cond[both_nan] = both_nan[both_nan]\n\n        return cond[()]  # Flatten 0d arrays to scalars\n\n\ndef _array_equal_dispatcher(a1, a2, equal_nan=None):\n    return (a1, a2)\n\n\n@array_function_dispatch(_array_equal_dispatcher)\ndef array_equal(a1, a2, equal_nan=False):\n    \"\"\"\n    True if two arrays have the same shape and elements, False otherwise.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n    equal_nan : bool\n        Whether to compare NaN's as equal. If the dtype of a1 and a2 is\n        complex, values will be considered equal if either the real or the\n        imaginary component of a given value is ``nan``.\n\n        .. versionadded:: 1.19.0\n\n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equal.\n\n    See Also\n    --------\n    allclose: Returns True if two arrays are element-wise equal within a\n              tolerance.\n    array_equiv: Returns True if input arrays are shape consistent and all\n                 elements equal.\n\n    Examples\n    --------\n    >>> np.array_equal([1, 2], [1, 2])\n    True\n    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))\n    True\n    >>> np.array_equal([1, 2], [1, 2, 3])\n    False\n    >>> np.array_equal([1, 2], [1, 4])\n    False\n    >>> a = np.array([1, np.nan])\n    >>> np.array_equal(a, a)\n    False\n    >>> np.array_equal(a, a, equal_nan=True)\n    True\n\n    When ``equal_nan`` is True, complex values with nan components are\n    considered equal if either the real *or* the imaginary components are nan.\n\n    >>> a = np.array([1 + 1j])\n    >>> b = a.copy()\n    >>> a.real = np.nan\n    >>> b.imag = np.nan\n    >>> np.array_equal(a, b, equal_nan=True)\n    True\n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    if a1.shape != a2.shape:\n        return False\n    if not equal_nan:\n        return bool(asarray(a1 == a2).all())\n    # Handling NaN values if equal_nan is True\n    a1nan, a2nan = isnan(a1), isnan(a2)\n    # NaN's occur at different locations\n    if not (a1nan == a2nan).all():\n        return False\n    # Shapes of a1, a2 and masks are guaranteed to be consistent by this point\n    return bool(asarray(a1[~a1nan] == a2[~a1nan]).all())\n\n\ndef _array_equiv_dispatcher(a1, a2):\n    return (a1, a2)\n\n\n@array_function_dispatch(_array_equiv_dispatcher)\ndef array_equiv(a1, a2):\n    \"\"\"\n    Returns True if input arrays are shape consistent and all elements equal.\n\n    Shape consistent means they are either the same shape, or one input array\n    can be broadcasted to create the same shape as the other one.\n\n    Parameters\n    ----------\n    a1, a2 : array_like\n        Input arrays.\n\n    Returns\n    -------\n    out : bool\n        True if equivalent, False otherwise.\n\n    Examples\n    --------\n    >>> np.array_equiv([1, 2], [1, 2])\n    True\n    >>> np.array_equiv([1, 2], [1, 3])\n    False\n\n    Showing the shape equivalence:\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])\n    True\n    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\n    False\n\n    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])\n    False\n\n    \"\"\"\n    try:\n        a1, a2 = asarray(a1), asarray(a2)\n    except Exception:\n        return False\n    try:\n        multiarray.broadcast(a1, a2)\n    except Exception:\n        return False\n\n    return bool(asarray(a1 == a2).all())\n\n\nInf = inf = infty = Infinity = PINF\nnan = NaN = NAN\nFalse_ = bool_(False)\nTrue_ = bool_(True)\n\n\ndef extend_all(module):\n    existing = set(__all__)\n    mall = getattr(module, '__all__')\n    for a in mall:\n        if a not in existing:\n            __all__.append(a)\n\n\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom .umath import *\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom .numerictypes import *\nfrom . import fromnumeric\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom .fromnumeric import *\nfrom . import arrayprint\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom .arrayprint import *\nfrom . import _asarray\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom ._asarray import *\nfrom . import _ufunc_config\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom ._ufunc_config import *\nextend_all(fromnumeric)\nextend_all(umath)\nextend_all(numerictypes)\nextend_all(arrayprint)\nextend_all(_asarray)\nextend_all(_ufunc_config)\n",
            "fixNo": "IL-M-1",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>numeric.py</span>, a module is imported using the wildcard symbol. This will import <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>public name from this module</a> and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "numeric.py4576565197850816665.diff"
            ]
        },
        {
            "fixerCustomHeading": "Avoid Wildcard Imports",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/capi_maps.py",
            "fixerCategoryTag": "PyCSI-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:45 UTC 2024",
            "fixerCustomMessageText": "In file: capi_maps.py, a module is imported using the wildcard symbol. This will import public name from this module and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "#!/usr/bin/env python3\n\"\"\"\n\nCopyright 1999,2000 Pearu Peterson all rights reserved,\nPearu Peterson <pearu@ioc.ee>\nPermission to use, modify, and distribute this software is given under the\nterms of the NumPy License.\n\nNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.\n$Date: 2005/05/06 10:57:33 $\nPearu Peterson\n\n\"\"\"\nfrom . import __version__\nf2py_version = __version__.version\n\nimport copy\nimport re\nimport os\nfrom .crackfortran import markoutercomma\nfrom . import cb_rules\n\n# The environment provided by auxfuncs.py is needed for some calls to eval.\n# As the needed functions cannot be determined by static inspection of the\n# code, it is safest to use import * pending a major refactoring of f2py.\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom .auxfuncs import *\n\n__all__ = [\n    'getctype', 'getstrlength', 'getarrdims', 'getpydocsign',\n    'getarrdocsign', 'getinit', 'sign2map', 'routsign2map', 'modsign2map',\n    'cb_sign2map', 'cb_routsign2map', 'common_sign2map'\n]\n\n\n# Numarray and Numeric users should set this False\nusing_newcore = True\n\ndepargs = []\nlcb_map = {}\nlcb2_map = {}\n# forced casting: mainly caused by the fact that Python or Numeric\n#                 C/APIs do not support the corresponding C types.\nc2py_map = {'double': 'float',\n            'float': 'float',                          # forced casting\n            'long_double': 'float',                    # forced casting\n            'char': 'int',                             # forced casting\n            'signed_char': 'int',                      # forced casting\n            'unsigned_char': 'int',                    # forced casting\n            'short': 'int',                            # forced casting\n            'unsigned_short': 'int',                   # forced casting\n            'int': 'int',                              # forced casting\n            'long': 'int',\n            'long_long': 'long',\n            'unsigned': 'int',                         # forced casting\n            'complex_float': 'complex',                # forced casting\n            'complex_double': 'complex',\n            'complex_long_double': 'complex',          # forced casting\n            'string': 'string',\n            'character': 'bytes',\n            }\nc2capi_map = {'double': 'NPY_DOUBLE',\n              'float': 'NPY_FLOAT',\n              'long_double': 'NPY_DOUBLE',           # forced casting\n              'char': 'NPY_STRING',\n              'unsigned_char': 'NPY_UBYTE',\n              'signed_char': 'NPY_BYTE',\n              'short': 'NPY_SHORT',\n              'unsigned_short': 'NPY_USHORT',\n              'int': 'NPY_INT',\n              'unsigned': 'NPY_UINT',\n              'long': 'NPY_LONG',\n              'long_long': 'NPY_LONG',                # forced casting\n              'complex_float': 'NPY_CFLOAT',\n              'complex_double': 'NPY_CDOUBLE',\n              'complex_long_double': 'NPY_CDOUBLE',   # forced casting\n              'string': 'NPY_STRING',\n              'character': 'NPY_CHAR'}\n\n# These new maps aren't used anywhere yet, but should be by default\n#  unless building numeric or numarray extensions.\nif using_newcore:\n    c2capi_map = {'double': 'NPY_DOUBLE',\n                  'float': 'NPY_FLOAT',\n                  'long_double': 'NPY_LONGDOUBLE',\n                  'char': 'NPY_BYTE',\n                  'unsigned_char': 'NPY_UBYTE',\n                  'signed_char': 'NPY_BYTE',\n                  'short': 'NPY_SHORT',\n                  'unsigned_short': 'NPY_USHORT',\n                  'int': 'NPY_INT',\n                  'unsigned': 'NPY_UINT',\n                  'long': 'NPY_LONG',\n                  'unsigned_long': 'NPY_ULONG',\n                  'long_long': 'NPY_LONGLONG',\n                  'unsigned_long_long': 'NPY_ULONGLONG',\n                  'complex_float': 'NPY_CFLOAT',\n                  'complex_double': 'NPY_CDOUBLE',\n                  'complex_long_double': 'NPY_CDOUBLE',\n                  'string': 'NPY_STRING',\n                  'character': 'NPY_STRING'}\n\nc2pycode_map = {'double': 'd',\n                'float': 'f',\n                'long_double': 'd',                       # forced casting\n                'char': '1',\n                'signed_char': '1',\n                'unsigned_char': 'b',\n                'short': 's',\n                'unsigned_short': 'w',\n                'int': 'i',\n                'unsigned': 'u',\n                'long': 'l',\n                'long_long': 'L',\n                'complex_float': 'F',\n                'complex_double': 'D',\n                'complex_long_double': 'D',               # forced casting\n                'string': 'c',\n                'character': 'c'\n                }\n\nif using_newcore:\n    c2pycode_map = {'double': 'd',\n                    'float': 'f',\n                    'long_double': 'g',\n                    'char': 'b',\n                    'unsigned_char': 'B',\n                    'signed_char': 'b',\n                    'short': 'h',\n                    'unsigned_short': 'H',\n                    'int': 'i',\n                    'unsigned': 'I',\n                    'long': 'l',\n                    'unsigned_long': 'L',\n                    'long_long': 'q',\n                    'unsigned_long_long': 'Q',\n                    'complex_float': 'F',\n                    'complex_double': 'D',\n                    'complex_long_double': 'G',\n                    'string': 'S',\n                    'character': 'c'}\n\n# https://docs.python.org/3/c-api/arg.html#building-values\n# c2buildvalue_map is NumPy agnostic, so no need to bother with using_newcore\nc2buildvalue_map = {'double': 'd',\n                    'float': 'f',\n                    'char': 'b',\n                    'signed_char': 'b',\n                    'short': 'h',\n                    'int': 'i',\n                    'long': 'l',\n                    'long_long': 'L',\n                    'complex_float': 'N',\n                    'complex_double': 'N',\n                    'complex_long_double': 'N',\n                    'string': 'y',\n                    'character': 'c'}\n\nf2cmap_all = {'real': {'': 'float', '4': 'float', '8': 'double',\n                       '12': 'long_double', '16': 'long_double'},\n              'integer': {'': 'int', '1': 'signed_char', '2': 'short',\n                          '4': 'int', '8': 'long_long',\n                          '-1': 'unsigned_char', '-2': 'unsigned_short',\n                          '-4': 'unsigned', '-8': 'unsigned_long_long'},\n              'complex': {'': 'complex_float', '8': 'complex_float',\n                          '16': 'complex_double', '24': 'complex_long_double',\n                          '32': 'complex_long_double'},\n              'complexkind': {'': 'complex_float', '4': 'complex_float',\n                              '8': 'complex_double', '12': 'complex_long_double',\n                              '16': 'complex_long_double'},\n              'logical': {'': 'int', '1': 'char', '2': 'short', '4': 'int',\n                          '8': 'long_long'},\n              'double complex': {'': 'complex_double'},\n              'double precision': {'': 'double'},\n              'byte': {'': 'char'},\n              }\n\nf2cmap_default = copy.deepcopy(f2cmap_all)\n\nf2cmap_mapped = []\n\ndef load_f2cmap_file(f2cmap_file):\n    global f2cmap_all\n\n    f2cmap_all = copy.deepcopy(f2cmap_default)\n\n    if f2cmap_file is None:\n        # Default value\n        f2cmap_file = '.f2py_f2cmap'\n        if not os.path.isfile(f2cmap_file):\n            return\n\n    # User defined additions to f2cmap_all.\n    # f2cmap_file must contain a dictionary of dictionaries, only. For\n    # example, {'real':{'low':'float'}} means that Fortran 'real(low)' is\n    # interpreted as C 'float'. This feature is useful for F90/95 users if\n    # they use PARAMETERS in type specifications.\n    try:\n        outmess('Reading f2cmap from {!r} ...\\n'.format(f2cmap_file))\n        with open(f2cmap_file) as f:\n            d = eval(f.read().lower(), {}, {})\n        for k, d1 in d.items():\n            for k1 in d1.keys():\n                d1[k1.lower()] = d1[k1]\n            d[k.lower()] = d[k]\n        for k in d.keys():\n            if k not in f2cmap_all:\n                f2cmap_all[k] = {}\n            for k1 in d[k].keys():\n                if d[k][k1] in c2py_map:\n                    if k1 in f2cmap_all[k]:\n                        outmess(\n                            \"\\tWarning: redefinition of {'%s':{'%s':'%s'->'%s'}}\\n\" % (k, k1, f2cmap_all[k][k1], d[k][k1]))\n                    f2cmap_all[k][k1] = d[k][k1]\n                    outmess('\\tMapping \"%s(kind=%s)\" to \"%s\"\\n' %\n                            (k, k1, d[k][k1]))\n                    f2cmap_mapped.append(d[k][k1])\n                else:\n                    errmess(\"\\tIgnoring map {'%s':{'%s':'%s'}}: '%s' must be in %s\\n\" % (\n                        k, k1, d[k][k1], d[k][k1], list(c2py_map.keys())))\n        outmess('Successfully applied user defined f2cmap changes\\n')\n    except Exception as msg:\n        errmess(\n            'Failed to apply user defined f2cmap changes: %s. Skipping.\\n' % (msg))\n\ncformat_map = {'double': '%g',\n               'float': '%g',\n               'long_double': '%Lg',\n               'char': '%d',\n               'signed_char': '%d',\n               'unsigned_char': '%hhu',\n               'short': '%hd',\n               'unsigned_short': '%hu',\n               'int': '%d',\n               'unsigned': '%u',\n               'long': '%ld',\n               'unsigned_long': '%lu',\n               'long_long': '%ld',\n               'complex_float': '(%g,%g)',\n               'complex_double': '(%g,%g)',\n               'complex_long_double': '(%Lg,%Lg)',\n               'string': '\\\\\"%s\\\\\"',\n               'character': \"'%c'\",\n               }\n\n# Auxiliary functions\n\n\ndef getctype(var):\n    \"\"\"\n    Determines C type\n    \"\"\"\n    ctype = 'void'\n    if isfunction(var):\n        if 'result' in var:\n            a = var['result']\n        else:\n            a = var['name']\n        if a in var['vars']:\n            return getctype(var['vars'][a])\n        else:\n            errmess('getctype: function %s has no return value?!\\n' % a)\n    elif issubroutine(var):\n        return ctype\n    elif ischaracter_or_characterarray(var):\n        return 'character'\n    elif isstring_or_stringarray(var):\n        return 'string'\n    elif 'typespec' in var and var['typespec'].lower() in f2cmap_all:\n        typespec = var['typespec'].lower()\n        f2cmap = f2cmap_all[typespec]\n        ctype = f2cmap['']  # default type\n        if 'kindselector' in var:\n            if '*' in var['kindselector']:\n                try:\n                    ctype = f2cmap[var['kindselector']['*']]\n                except KeyError:\n                    errmess('getctype: \"%s %s %s\" not supported.\\n' %\n                            (var['typespec'], '*', var['kindselector']['*']))\n            elif 'kind' in var['kindselector']:\n                if typespec + 'kind' in f2cmap_all:\n                    f2cmap = f2cmap_all[typespec + 'kind']\n                try:\n                    ctype = f2cmap[var['kindselector']['kind']]\n                except KeyError:\n                    if typespec in f2cmap_all:\n                        f2cmap = f2cmap_all[typespec]\n                    try:\n                        ctype = f2cmap[str(var['kindselector']['kind'])]\n                    except KeyError:\n                        errmess('getctype: \"%s(kind=%s)\" is mapped to C \"%s\" (to override define dict(%s = dict(%s=\"<C typespec>\")) in %s/.f2py_f2cmap file).\\n'\n                                % (typespec, var['kindselector']['kind'], ctype,\n                                   typespec, var['kindselector']['kind'], os.getcwd()))\n    else:\n        if not isexternal(var):\n            errmess('getctype: No C-type found in \"%s\", assuming void.\\n' % var)\n    return ctype\n\n\ndef f2cexpr(expr):\n    \"\"\"Rewrite Fortran expression as f2py supported C expression.\n\n    Due to the lack of a proper expression parser in f2py, this\n    function uses a heuristic approach that assumes that Fortran\n    arithmetic expressions are valid C arithmetic expressions when\n    mapping Fortran function calls to the corresponding C function/CPP\n    macros calls.\n\n    \"\"\"\n    # TODO: support Fortran `len` function with optional kind parameter\n    expr = re.sub(r'\\blen\\b', 'f2py_slen', expr)\n    return expr\n\n\ndef getstrlength(var):\n    if isstringfunction(var):\n        if 'result' in var:\n            a = var['result']\n        else:\n            a = var['name']\n        if a in var['vars']:\n            return getstrlength(var['vars'][a])\n        else:\n            errmess('getstrlength: function %s has no return value?!\\n' % a)\n    if not isstring(var):\n        errmess(\n            'getstrlength: expected a signature of a string but got: %s\\n' % (repr(var)))\n    len = '1'\n    if 'charselector' in var:\n        a = var['charselector']\n        if '*' in a:\n            len = a['*']\n        elif 'len' in a:\n            len = f2cexpr(a['len'])\n    if re.match(r'\\(\\s*(\\*|:)\\s*\\)', len) or re.match(r'(\\*|:)', len):\n        if isintent_hide(var):\n            errmess('getstrlength:intent(hide): expected a string with defined length but got: %s\\n' % (\n                repr(var)))\n        len = '-1'\n    return len\n\n\ndef getarrdims(a, var, verbose=0):\n    ret = {}\n    if isstring(var) and not isarray(var):\n        ret['size'] = getstrlength(var)\n        ret['rank'] = '0'\n        ret['dims'] = ''\n    elif isscalar(var):\n        ret['size'] = '1'\n        ret['rank'] = '0'\n        ret['dims'] = ''\n    elif isarray(var):\n        dim = copy.copy(var['dimension'])\n        ret['size'] = '*'.join(dim)\n        try:\n            ret['size'] = repr(eval(ret['size']))\n        except Exception:\n            pass\n        ret['dims'] = ','.join(dim)\n        ret['rank'] = repr(len(dim))\n        ret['rank*[-1]'] = repr(len(dim) * [-1])[1:-1]\n        for i in range(len(dim)):  # solve dim for dependencies\n            v = []\n            if dim[i] in depargs:\n                v = [dim[i]]\n            else:\n                for va in depargs:\n                    if re.match(r'.*?\\b%s\\b.*' % va, dim[i]):\n                        v.append(va)\n            for va in v:\n                if depargs.index(va) > depargs.index(a):\n                    dim[i] = '*'\n                    break\n        ret['setdims'], i = '', -1\n        for d in dim:\n            i = i + 1\n            if d not in ['*', ':', '(*)', '(:)']:\n                ret['setdims'] = '%s#varname#_Dims[%d]=%s,' % (\n                    ret['setdims'], i, d)\n        if ret['setdims']:\n            ret['setdims'] = ret['setdims'][:-1]\n        ret['cbsetdims'], i = '', -1\n        for d in var['dimension']:\n            i = i + 1\n            if d not in ['*', ':', '(*)', '(:)']:\n                ret['cbsetdims'] = '%s#varname#_Dims[%d]=%s,' % (\n                    ret['cbsetdims'], i, d)\n            elif isintent_in(var):\n                outmess('getarrdims:warning: assumed shape array, using 0 instead of %r\\n'\n                        % (d))\n                ret['cbsetdims'] = '%s#varname#_Dims[%d]=%s,' % (\n                    ret['cbsetdims'], i, 0)\n            elif verbose:\n                errmess(\n                    'getarrdims: If in call-back function: array argument %s must have bounded dimensions: got %s\\n' % (repr(a), repr(d)))\n        if ret['cbsetdims']:\n            ret['cbsetdims'] = ret['cbsetdims'][:-1]\n#         if not isintent_c(var):\n#             var['dimension'].reverse()\n    return ret\n\n\ndef getpydocsign(a, var):\n    global lcb_map\n    if isfunction(var):\n        if 'result' in var:\n            af = var['result']\n        else:\n            af = var['name']\n        if af in var['vars']:\n            return getpydocsign(af, var['vars'][af])\n        else:\n            errmess('getctype: function %s has no return value?!\\n' % af)\n        return '', ''\n    sig, sigout = a, a\n    opt = ''\n    if isintent_in(var):\n        opt = 'input'\n    elif isintent_inout(var):\n        opt = 'in/output'\n    out_a = a\n    if isintent_out(var):\n        for k in var['intent']:\n            if k[:4] == 'out=':\n                out_a = k[4:]\n                break\n    init = ''\n    ctype = getctype(var)\n\n    if hasinitvalue(var):\n        init, showinit = getinit(a, var)\n        init = ', optional\\\\n    Default: %s' % showinit\n    if isscalar(var):\n        if isintent_inout(var):\n            sig = '%s : %s rank-0 array(%s,\\'%s\\')%s' % (a, opt, c2py_map[ctype],\n                                                         c2pycode_map[ctype], init)\n        else:\n            sig = '%s : %s %s%s' % (a, opt, c2py_map[ctype], init)\n        sigout = '%s : %s' % (out_a, c2py_map[ctype])\n    elif isstring(var):\n        if isintent_inout(var):\n            sig = '%s : %s rank-0 array(string(len=%s),\\'c\\')%s' % (\n                a, opt, getstrlength(var), init)\n        else:\n            sig = '%s : %s string(len=%s)%s' % (\n                a, opt, getstrlength(var), init)\n        sigout = '%s : string(len=%s)' % (out_a, getstrlength(var))\n    elif isarray(var):\n        dim = var['dimension']\n        rank = repr(len(dim))\n        sig = '%s : %s rank-%s array(\\'%s\\') with bounds (%s)%s' % (a, opt, rank,\n                                                                    c2pycode_map[\n                                                                        ctype],\n                                                                    ','.join(dim), init)\n        if a == out_a:\n            sigout = '%s : rank-%s array(\\'%s\\') with bounds (%s)'\\\n                % (a, rank, c2pycode_map[ctype], ','.join(dim))\n        else:\n            sigout = '%s : rank-%s array(\\'%s\\') with bounds (%s) and %s storage'\\\n                % (out_a, rank, c2pycode_map[ctype], ','.join(dim), a)\n    elif isexternal(var):\n        ua = ''\n        if a in lcb_map and lcb_map[a] in lcb2_map and 'argname' in lcb2_map[lcb_map[a]]:\n            ua = lcb2_map[lcb_map[a]]['argname']\n            if not ua == a:\n                ua = ' => %s' % ua\n            else:\n                ua = ''\n        sig = '%s : call-back function%s' % (a, ua)\n        sigout = sig\n    else:\n        errmess(\n            'getpydocsign: Could not resolve docsignature for \"%s\".\\n' % a)\n    return sig, sigout\n\n\ndef getarrdocsign(a, var):\n    ctype = getctype(var)\n    if isstring(var) and (not isarray(var)):\n        sig = '%s : rank-0 array(string(len=%s),\\'c\\')' % (a,\n                                                           getstrlength(var))\n    elif isscalar(var):\n        sig = '%s : rank-0 array(%s,\\'%s\\')' % (a, c2py_map[ctype],\n                                                c2pycode_map[ctype],)\n    elif isarray(var):\n        dim = var['dimension']\n        rank = repr(len(dim))\n        sig = '%s : rank-%s array(\\'%s\\') with bounds (%s)' % (a, rank,\n                                                               c2pycode_map[\n                                                                   ctype],\n                                                               ','.join(dim))\n    return sig\n\n\ndef getinit(a, var):\n    if isstring(var):\n        init, showinit = '\"\"', \"''\"\n    else:\n        init, showinit = '', ''\n    if hasinitvalue(var):\n        init = var['=']\n        showinit = init\n        if iscomplex(var) or iscomplexarray(var):\n            ret = {}\n\n            try:\n                v = var[\"=\"]\n                if ',' in v:\n                    ret['init.r'], ret['init.i'] = markoutercomma(\n                        v[1:-1]).split('@,@')\n                else:\n                    v = eval(v, {}, {})\n                    ret['init.r'], ret['init.i'] = str(v.real), str(v.imag)\n            except Exception:\n                raise ValueError(\n                    'getinit: expected complex number `(r,i)\\' but got `%s\\' as initial value of %r.' % (init, a))\n            if isarray(var):\n                init = '(capi_c.r=%s,capi_c.i=%s,capi_c)' % (\n                    ret['init.r'], ret['init.i'])\n        elif isstring(var):\n            if not init:\n                init, showinit = '\"\"', \"''\"\n            if init[0] == \"'\":\n                init = '\"%s\"' % (init[1:-1].replace('\"', '\\\\\"'))\n            if init[0] == '\"':\n                showinit = \"'%s'\" % (init[1:-1])\n    return init, showinit\n\n\ndef get_elsize(var):\n    if isstring(var) or isstringarray(var):\n        elsize = getstrlength(var)\n        # override with user-specified length when available:\n        elsize = var['charselector'].get('f2py_len', elsize)\n        return elsize\n    if ischaracter(var) or ischaracterarray(var):\n        return '1'\n    # for numerical types, PyArray_New* functions ignore specified\n    # elsize, so we just return 1 and let elsize be determined at\n    # runtime, see fortranobject.c\n    return '1'\n\n\ndef sign2map(a, var):\n    \"\"\"\n    varname,ctype,atype\n    init,init.r,init.i,pytype\n    vardebuginfo,vardebugshowvalue,varshowvalue\n    varrformat\n\n    intent\n    \"\"\"\n    out_a = a\n    if isintent_out(var):\n        for k in var['intent']:\n            if k[:4] == 'out=':\n                out_a = k[4:]\n                break\n    ret = {'varname': a, 'outvarname': out_a, 'ctype': getctype(var)}\n    intent_flags = []\n    for f, s in isintent_dict.items():\n        if f(var):\n            intent_flags.append('F2PY_%s' % s)\n    if intent_flags:\n        # TODO: Evaluate intent_flags here.\n        ret['intent'] = '|'.join(intent_flags)\n    else:\n        ret['intent'] = 'F2PY_INTENT_IN'\n    if isarray(var):\n        ret['varrformat'] = 'N'\n    elif ret['ctype'] in c2buildvalue_map:\n        ret['varrformat'] = c2buildvalue_map[ret['ctype']]\n    else:\n        ret['varrformat'] = 'O'\n    ret['init'], ret['showinit'] = getinit(a, var)\n    if hasinitvalue(var) and iscomplex(var) and not isarray(var):\n        ret['init.r'], ret['init.i'] = markoutercomma(\n            ret['init'][1:-1]).split('@,@')\n    if isexternal(var):\n        ret['cbnamekey'] = a\n        if a in lcb_map:\n            ret['cbname'] = lcb_map[a]\n            ret['maxnofargs'] = lcb2_map[lcb_map[a]]['maxnofargs']\n            ret['nofoptargs'] = lcb2_map[lcb_map[a]]['nofoptargs']\n            ret['cbdocstr'] = lcb2_map[lcb_map[a]]['docstr']\n            ret['cblatexdocstr'] = lcb2_map[lcb_map[a]]['latexdocstr']\n        else:\n            ret['cbname'] = a\n            errmess('sign2map: Confused: external %s is not in lcb_map%s.\\n' % (\n                a, list(lcb_map.keys())))\n    if isstring(var):\n        ret['length'] = getstrlength(var)\n    if isarray(var):\n        ret = dictappend(ret, getarrdims(a, var))\n        dim = copy.copy(var['dimension'])\n    if ret['ctype'] in c2capi_map:\n        ret['atype'] = c2capi_map[ret['ctype']]\n        ret['elsize'] = get_elsize(var)\n    # Debug info\n    if debugcapi(var):\n        il = [isintent_in, 'input', isintent_out, 'output',\n              isintent_inout, 'inoutput', isrequired, 'required',\n              isoptional, 'optional', isintent_hide, 'hidden',\n              iscomplex, 'complex scalar',\n              l_and(isscalar, l_not(iscomplex)), 'scalar',\n              isstring, 'string', isarray, 'array',\n              iscomplexarray, 'complex array', isstringarray, 'string array',\n              iscomplexfunction, 'complex function',\n              l_and(isfunction, l_not(iscomplexfunction)), 'function',\n              isexternal, 'callback',\n              isintent_callback, 'callback',\n              isintent_aux, 'auxiliary',\n              ]\n        rl = []\n        for i in range(0, len(il), 2):\n            if il[i](var):\n                rl.append(il[i + 1])\n        if isstring(var):\n            rl.append('slen(%s)=%s' % (a, ret['length']))\n        if isarray(var):\n            ddim = ','.join(\n                map(lambda x, y: '%s|%s' % (x, y), var['dimension'], dim))\n            rl.append('dims(%s)' % ddim)\n        if isexternal(var):\n            ret['vardebuginfo'] = 'debug-capi:%s=>%s:%s' % (\n                a, ret['cbname'], ','.join(rl))\n        else:\n            ret['vardebuginfo'] = 'debug-capi:%s %s=%s:%s' % (\n                ret['ctype'], a, ret['showinit'], ','.join(rl))\n        if isscalar(var):\n            if ret['ctype'] in cformat_map:\n                ret['vardebugshowvalue'] = 'debug-capi:%s=%s' % (\n                    a, cformat_map[ret['ctype']])\n        if isstring(var):\n            ret['vardebugshowvalue'] = 'debug-capi:slen(%s)=%%d %s=\\\\\"%%s\\\\\"' % (\n                a, a)\n        if isexternal(var):\n            ret['vardebugshowvalue'] = 'debug-capi:%s=%%p' % (a)\n    if ret['ctype'] in cformat_map:\n        ret['varshowvalue'] = '#name#:%s=%s' % (a, cformat_map[ret['ctype']])\n        ret['showvalueformat'] = '%s' % (cformat_map[ret['ctype']])\n    if isstring(var):\n        ret['varshowvalue'] = '#name#:slen(%s)=%%d %s=\\\\\"%%s\\\\\"' % (a, a)\n    ret['pydocsign'], ret['pydocsignout'] = getpydocsign(a, var)\n    if hasnote(var):\n        ret['note'] = var['note']\n    return ret\n\n\ndef routsign2map(rout):\n    \"\"\"\n    name,NAME,begintitle,endtitle\n    rname,ctype,rformat\n    routdebugshowvalue\n    \"\"\"\n    global lcb_map\n    name = rout['name']\n    fname = getfortranname(rout)\n    ret = {'name': name,\n           'texname': name.replace('_', '\\\\_'),\n           'name_lower': name.lower(),\n           'NAME': name.upper(),\n           'begintitle': gentitle(name),\n           'endtitle': gentitle('end of %s' % name),\n           'fortranname': fname,\n           'FORTRANNAME': fname.upper(),\n           'callstatement': getcallstatement(rout) or '',\n           'usercode': getusercode(rout) or '',\n           'usercode1': getusercode1(rout) or '',\n           }\n    if '_' in fname:\n        ret['F_FUNC'] = 'F_FUNC_US'\n    else:\n        ret['F_FUNC'] = 'F_FUNC'\n    if '_' in name:\n        ret['F_WRAPPEDFUNC'] = 'F_WRAPPEDFUNC_US'\n    else:\n        ret['F_WRAPPEDFUNC'] = 'F_WRAPPEDFUNC'\n    lcb_map = {}\n    if 'use' in rout:\n        for u in rout['use'].keys():\n            if u in cb_rules.cb_map:\n                for un in cb_rules.cb_map[u]:\n                    ln = un[0]\n                    if 'map' in rout['use'][u]:\n                        for k in rout['use'][u]['map'].keys():\n                            if rout['use'][u]['map'][k] == un[0]:\n                                ln = k\n                                break\n                    lcb_map[ln] = un[1]\n    elif 'externals' in rout and rout['externals']:\n        errmess('routsign2map: Confused: function %s has externals %s but no \"use\" statement.\\n' % (\n            ret['name'], repr(rout['externals'])))\n    ret['callprotoargument'] = getcallprotoargument(rout, lcb_map) or ''\n    if isfunction(rout):\n        if 'result' in rout:\n            a = rout['result']\n        else:\n            a = rout['name']\n        ret['rname'] = a\n        ret['pydocsign'], ret['pydocsignout'] = getpydocsign(a, rout)\n        ret['ctype'] = getctype(rout['vars'][a])\n        if hasresultnote(rout):\n            ret['resultnote'] = rout['vars'][a]['note']\n            rout['vars'][a]['note'] = ['See elsewhere.']\n        if ret['ctype'] in c2buildvalue_map:\n            ret['rformat'] = c2buildvalue_map[ret['ctype']]\n        else:\n            ret['rformat'] = 'O'\n            errmess('routsign2map: no c2buildvalue key for type %s\\n' %\n                    (repr(ret['ctype'])))\n        if debugcapi(rout):\n            if ret['ctype'] in cformat_map:\n                ret['routdebugshowvalue'] = 'debug-capi:%s=%s' % (\n                    a, cformat_map[ret['ctype']])\n            if isstringfunction(rout):\n                ret['routdebugshowvalue'] = 'debug-capi:slen(%s)=%%d %s=\\\\\"%%s\\\\\"' % (\n                    a, a)\n        if isstringfunction(rout):\n            ret['rlength'] = getstrlength(rout['vars'][a])\n            if ret['rlength'] == '-1':\n                errmess('routsign2map: expected explicit specification of the length of the string returned by the fortran function %s; taking 10.\\n' % (\n                    repr(rout['name'])))\n                ret['rlength'] = '10'\n    if hasnote(rout):\n        ret['note'] = rout['note']\n        rout['note'] = ['See elsewhere.']\n    return ret\n\n\ndef modsign2map(m):\n    \"\"\"\n    modulename\n    \"\"\"\n    if ismodule(m):\n        ret = {'f90modulename': m['name'],\n               'F90MODULENAME': m['name'].upper(),\n               'texf90modulename': m['name'].replace('_', '\\\\_')}\n    else:\n        ret = {'modulename': m['name'],\n               'MODULENAME': m['name'].upper(),\n               'texmodulename': m['name'].replace('_', '\\\\_')}\n    ret['restdoc'] = getrestdoc(m) or []\n    if hasnote(m):\n        ret['note'] = m['note']\n    ret['usercode'] = getusercode(m) or ''\n    ret['usercode1'] = getusercode1(m) or ''\n    if m['body']:\n        ret['interface_usercode'] = getusercode(m['body'][0]) or ''\n    else:\n        ret['interface_usercode'] = ''\n    ret['pymethoddef'] = getpymethoddef(m) or ''\n    if 'coutput' in m:\n        ret['coutput'] = m['coutput']\n    if 'f2py_wrapper_output' in m:\n        ret['f2py_wrapper_output'] = m['f2py_wrapper_output']\n    return ret\n\n\ndef cb_sign2map(a, var, index=None):\n    ret = {'varname': a}\n    ret['varname_i'] = ret['varname']\n    ret['ctype'] = getctype(var)\n    if ret['ctype'] in c2capi_map:\n        ret['atype'] = c2capi_map[ret['ctype']]\n        ret['elsize'] = get_elsize(var)\n    if ret['ctype'] in cformat_map:\n        ret['showvalueformat'] = '%s' % (cformat_map[ret['ctype']])\n    if isarray(var):\n        ret = dictappend(ret, getarrdims(a, var))\n    ret['pydocsign'], ret['pydocsignout'] = getpydocsign(a, var)\n    if hasnote(var):\n        ret['note'] = var['note']\n        var['note'] = ['See elsewhere.']\n    return ret\n\n\ndef cb_routsign2map(rout, um):\n    \"\"\"\n    name,begintitle,endtitle,argname\n    ctype,rctype,maxnofargs,nofoptargs,returncptr\n    \"\"\"\n    ret = {'name': 'cb_%s_in_%s' % (rout['name'], um),\n           'returncptr': ''}\n    if isintent_callback(rout):\n        if '_' in rout['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        ret['callbackname'] = '%s(%s,%s)' \\\n                              % (F_FUNC,\n                                 rout['name'].lower(),\n                                 rout['name'].upper(),\n                                 )\n        ret['static'] = 'extern'\n    else:\n        ret['callbackname'] = ret['name']\n        ret['static'] = 'static'\n    ret['argname'] = rout['name']\n    ret['begintitle'] = gentitle(ret['name'])\n    ret['endtitle'] = gentitle('end of %s' % ret['name'])\n    ret['ctype'] = getctype(rout)\n    ret['rctype'] = 'void'\n    if ret['ctype'] == 'string':\n        ret['rctype'] = 'void'\n    else:\n        ret['rctype'] = ret['ctype']\n    if ret['rctype'] != 'void':\n        if iscomplexfunction(rout):\n            ret['returncptr'] = \"\"\"\n#ifdef F2PY_CB_RETURNCOMPLEX\nreturn_value=\n#endif\n\"\"\"\n        else:\n            ret['returncptr'] = 'return_value='\n    if ret['ctype'] in cformat_map:\n        ret['showvalueformat'] = '%s' % (cformat_map[ret['ctype']])\n    if isstringfunction(rout):\n        ret['strlength'] = getstrlength(rout)\n    if isfunction(rout):\n        if 'result' in rout:\n            a = rout['result']\n        else:\n            a = rout['name']\n        if hasnote(rout['vars'][a]):\n            ret['note'] = rout['vars'][a]['note']\n            rout['vars'][a]['note'] = ['See elsewhere.']\n        ret['rname'] = a\n        ret['pydocsign'], ret['pydocsignout'] = getpydocsign(a, rout)\n        if iscomplexfunction(rout):\n            ret['rctype'] = \"\"\"\n#ifdef F2PY_CB_RETURNCOMPLEX\n#ctype#\n#else\nvoid\n#endif\n\"\"\"\n    else:\n        if hasnote(rout):\n            ret['note'] = rout['note']\n            rout['note'] = ['See elsewhere.']\n    nofargs = 0\n    nofoptargs = 0\n    if 'args' in rout and 'vars' in rout:\n        for a in rout['args']:\n            var = rout['vars'][a]\n            if l_or(isintent_in, isintent_inout)(var):\n                nofargs = nofargs + 1\n                if isoptional(var):\n                    nofoptargs = nofoptargs + 1\n    ret['maxnofargs'] = repr(nofargs)\n    ret['nofoptargs'] = repr(nofoptargs)\n    if hasnote(rout) and isfunction(rout) and 'result' in rout:\n        ret['routnote'] = rout['note']\n        rout['note'] = ['See elsewhere.']\n    return ret\n\n\ndef common_sign2map(a, var):  # obsolute\n    ret = {'varname': a, 'ctype': getctype(var)}\n    if isstringarray(var):\n        ret['ctype'] = 'char'\n    if ret['ctype'] in c2capi_map:\n        ret['atype'] = c2capi_map[ret['ctype']]\n        ret['elsize'] = get_elsize(var)\n    if ret['ctype'] in cformat_map:\n        ret['showvalueformat'] = '%s' % (cformat_map[ret['ctype']])\n    if isarray(var):\n        ret = dictappend(ret, getarrdims(a, var))\n    elif isstring(var):\n        ret['size'] = getstrlength(var)\n        ret['rank'] = '1'\n    ret['pydocsign'], ret['pydocsignout'] = getpydocsign(a, var)\n    if hasnote(var):\n        ret['note'] = var['note']\n        var['note'] = ['See elsewhere.']\n    # for strings this returns 0-rank but actually is 1-rank\n    ret['arrdocstr'] = getarrdocsign(a, var)\n    return ret\n",
            "fixNo": "IL-M-2",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>capi_maps.py</span>, a module is imported using the wildcard symbol. This will import <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>public name from this module</a> and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "capi_maps.py4388961993227624686.diff"
            ]
        },
        {
            "fixerCustomHeading": "Avoid Wildcard Imports",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a module is imported using the wildcard symbol. This will import public name from this module and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "#!/usr/bin/env python3\n\"\"\"\ncrackfortran --- read fortran (77,90) code and extract declaration information.\n\nCopyright 1999-2004 Pearu Peterson all rights reserved,\nPearu Peterson <pearu@ioc.ee>\nPermission to use, modify, and distribute this software is given under the\nterms of the NumPy License.\n\nNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.\n$Date: 2005/09/27 07:13:49 $\nPearu Peterson\n\n\nUsage of crackfortran:\n======================\nCommand line keys: -quiet,-verbose,-fix,-f77,-f90,-show,-h <pyffilename>\n                   -m <module name for f77 routines>,--ignore-contains\nFunctions: crackfortran, crack2fortran\nThe following Fortran statements/constructions are supported\n(or will be if needed):\n   block data,byte,call,character,common,complex,contains,data,\n   dimension,double complex,double precision,end,external,function,\n   implicit,integer,intent,interface,intrinsic,\n   logical,module,optional,parameter,private,public,\n   program,real,(sequence?),subroutine,type,use,virtual,\n   include,pythonmodule\nNote: 'virtual' is mapped to 'dimension'.\nNote: 'implicit integer (z) static (z)' is 'implicit static (z)' (this is minor bug).\nNote: code after 'contains' will be ignored until its scope ends.\nNote: 'common' statement is extended: dimensions are moved to variable definitions\nNote: f2py directive: <commentchar>f2py<line> is read as <line>\nNote: pythonmodule is introduced to represent Python module\n\nUsage:\n  `postlist=crackfortran(files)`\n  `postlist` contains declaration information read from the list of files `files`.\n  `crack2fortran(postlist)` returns a fortran code to be saved to pyf-file\n\n  `postlist` has the following structure:\n *** it is a list of dictionaries containing `blocks':\n     B = {'block','body','vars','parent_block'[,'name','prefix','args','result',\n          'implicit','externals','interfaced','common','sortvars',\n          'commonvars','note']}\n     B['block'] = 'interface' | 'function' | 'subroutine' | 'module' |\n                  'program' | 'block data' | 'type' | 'pythonmodule' |\n                  'abstract interface'\n     B['body'] --- list containing `subblocks' with the same structure as `blocks'\n     B['parent_block'] --- dictionary of a parent block:\n                             C['body'][<index>]['parent_block'] is C\n     B['vars'] --- dictionary of variable definitions\n     B['sortvars'] --- dictionary of variable definitions sorted by dependence (independent first)\n     B['name'] --- name of the block (not if B['block']=='interface')\n     B['prefix'] --- prefix string (only if B['block']=='function')\n     B['args'] --- list of argument names if B['block']== 'function' | 'subroutine'\n     B['result'] --- name of the return value (only if B['block']=='function')\n     B['implicit'] --- dictionary {'a':<variable definition>,'b':...} | None\n     B['externals'] --- list of variables being external\n     B['interfaced'] --- list of variables being external and defined\n     B['common'] --- dictionary of common blocks (list of objects)\n     B['commonvars'] --- list of variables used in common blocks (dimensions are moved to variable definitions)\n     B['from'] --- string showing the 'parents' of the current block\n     B['use'] --- dictionary of modules used in current block:\n         {<modulename>:{['only':<0|1>],['map':{<local_name1>:<use_name1>,...}]}}\n     B['note'] --- list of LaTeX comments on the block\n     B['f2pyenhancements'] --- optional dictionary\n          {'threadsafe':'','fortranname':<name>,\n           'callstatement':<C-expr>|<multi-line block>,\n           'callprotoargument':<C-expr-list>,\n           'usercode':<multi-line block>|<list of multi-line blocks>,\n           'pymethoddef:<multi-line block>'\n           }\n     B['entry'] --- dictionary {entryname:argslist,..}\n     B['varnames'] --- list of variable names given in the order of reading the\n                       Fortran code, useful for derived types.\n     B['saved_interface'] --- a string of scanned routine signature, defines explicit interface\n *** Variable definition is a dictionary\n     D = B['vars'][<variable name>] =\n     {'typespec'[,'attrspec','kindselector','charselector','=','typename']}\n     D['typespec'] = 'byte' | 'character' | 'complex' | 'double complex' |\n                     'double precision' | 'integer' | 'logical' | 'real' | 'type'\n     D['attrspec'] --- list of attributes (e.g. 'dimension(<arrayspec>)',\n                       'external','intent(in|out|inout|hide|c|callback|cache|aligned4|aligned8|aligned16)',\n                       'optional','required', etc)\n     K = D['kindselector'] = {['*','kind']} (only if D['typespec'] =\n                         'complex' | 'integer' | 'logical' | 'real' )\n     C = D['charselector'] = {['*','len','kind','f2py_len']}\n                             (only if D['typespec']=='character')\n     D['='] --- initialization expression string\n     D['typename'] --- name of the type if D['typespec']=='type'\n     D['dimension'] --- list of dimension bounds\n     D['intent'] --- list of intent specifications\n     D['depend'] --- list of variable names on which current variable depends on\n     D['check'] --- list of C-expressions; if C-expr returns zero, exception is raised\n     D['note'] --- list of LaTeX comments on the variable\n *** Meaning of kind/char selectors (few examples):\n     D['typespec>']*K['*']\n     D['typespec'](kind=K['kind'])\n     character*C['*']\n     character(len=C['len'],kind=C['kind'], f2py_len=C['f2py_len'])\n     (see also fortran type declaration statement formats below)\n\nFortran 90 type declaration statement format (F77 is subset of F90)\n====================================================================\n(Main source: IBM XL Fortran 5.1 Language Reference Manual)\ntype declaration = <typespec> [[<attrspec>]::] <entitydecl>\n<typespec> = byte                          |\n             character[<charselector>]     |\n             complex[<kindselector>]       |\n             double complex                |\n             double precision              |\n             integer[<kindselector>]       |\n             logical[<kindselector>]       |\n             real[<kindselector>]          |\n             type(<typename>)\n<charselector> = * <charlen>               |\n             ([len=]<len>[,[kind=]<kind>]) |\n             (kind=<kind>[,len=<len>])\n<kindselector> = * <intlen>                |\n             ([kind=]<kind>)\n<attrspec> = comma separated list of attributes.\n             Only the following attributes are used in\n             building up the interface:\n                external\n                (parameter --- affects '=' key)\n                optional\n                intent\n             Other attributes are ignored.\n<intentspec> = in | out | inout\n<arrayspec> = comma separated list of dimension bounds.\n<entitydecl> = <name> [[*<charlen>][(<arrayspec>)] | [(<arrayspec>)]*<charlen>]\n                      [/<init_expr>/ | =<init_expr>] [,<entitydecl>]\n\nIn addition, the following attributes are used: check,depend,note\n\nTODO:\n    * Apply 'parameter' attribute (e.g. 'integer parameter :: i=2' 'real x(i)'\n                                   -> 'real x(2)')\n    The above may be solved by creating appropriate preprocessor program, for example.\n\n\"\"\"\nimport sys\nimport string\nimport fileinput\nimport re\nimport os\nimport copy\nimport platform\nimport codecs\nfrom pathlib import Path\ntry:\n    import charset_normalizer\nexcept ImportError:\n    charset_normalizer = None\n\nfrom . import __version__\n\n# The environment provided by auxfuncs.py is needed for some calls to eval.\n# As the needed functions cannot be determined by static inspection of the\n# code, it is safest to use import * pending a major refactoring of f2py.\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom .auxfuncs import *\nfrom . import symbolic\n\nf2py_version = __version__.version\n\n# Global flags:\nstrictf77 = 1          # Ignore `!' comments unless line[0]=='!'\nsourcecodeform = 'fix'  # 'fix','free'\nquiet = 0              # Be verbose if 0 (Obsolete: not used any more)\nverbose = 1            # Be quiet if 0, extra verbose if > 1.\ntabchar = 4 * ' '\npyffilename = ''\nf77modulename = ''\nskipemptyends = 0      # for old F77 programs without 'program' statement\nignorecontains = 1\ndolowercase = 1\ndebug = []\n\n# Global variables\nbeginpattern = ''\ncurrentfilename = ''\nexpectbegin = 1\nf90modulevars = {}\nfilepositiontext = ''\ngotnextfile = 1\ngroupcache = None\ngroupcounter = 0\ngrouplist = {groupcounter: []}\ngroupname = ''\ninclude_paths = []\nneededmodule = -1\nonlyfuncs = []\nprevious_context = None\nskipblocksuntil = -1\nskipfuncs = []\nskipfunctions = []\nusermodules = []\n\n\ndef reset_global_f2py_vars():\n    global groupcounter, grouplist, neededmodule, expectbegin\n    global skipblocksuntil, usermodules, f90modulevars, gotnextfile\n    global filepositiontext, currentfilename, skipfunctions, skipfuncs\n    global onlyfuncs, include_paths, previous_context\n    global strictf77, sourcecodeform, quiet, verbose, tabchar, pyffilename\n    global f77modulename, skipemptyends, ignorecontains, dolowercase, debug\n\n    # flags\n    strictf77 = 1\n    sourcecodeform = 'fix'\n    quiet = 0\n    verbose = 1\n    tabchar = 4 * ' '\n    pyffilename = ''\n    f77modulename = ''\n    skipemptyends = 0\n    ignorecontains = 1\n    dolowercase = 1\n    debug = []\n    # variables\n    groupcounter = 0\n    grouplist = {groupcounter: []}\n    neededmodule = -1\n    expectbegin = 1\n    skipblocksuntil = -1\n    usermodules = []\n    f90modulevars = {}\n    gotnextfile = 1\n    filepositiontext = ''\n    currentfilename = ''\n    skipfunctions = []\n    skipfuncs = []\n    onlyfuncs = []\n    include_paths = []\n    previous_context = None\n\n\ndef outmess(line, flag=1):\n    global filepositiontext\n\n    if not verbose:\n        return\n    if not quiet:\n        if flag:\n            sys.stdout.write(filepositiontext)\n        sys.stdout.write(line)\n\nre._MAXCACHE = 50\ndefaultimplicitrules = {}\nfor c in \"abcdefghopqrstuvwxyz$_\":\n    defaultimplicitrules[c] = {'typespec': 'real'}\nfor c in \"ijklmn\":\n    defaultimplicitrules[c] = {'typespec': 'integer'}\nbadnames = {}\ninvbadnames = {}\nfor n in ['int', 'double', 'float', 'char', 'short', 'long', 'void', 'case', 'while',\n          'return', 'signed', 'unsigned', 'if', 'for', 'typedef', 'sizeof', 'union',\n          'struct', 'static', 'register', 'new', 'break', 'do', 'goto', 'switch',\n          'continue', 'else', 'inline', 'extern', 'delete', 'const', 'auto',\n          'len', 'rank', 'shape', 'index', 'slen', 'size', '_i',\n          'max', 'min',\n          'flen', 'fshape',\n          'string', 'complex_double', 'float_double', 'stdin', 'stderr', 'stdout',\n          'type', 'default']:\n    badnames[n] = n + '_bn'\n    invbadnames[n + '_bn'] = n\n\n\ndef rmbadname1(name):\n    if name in badnames:\n        errmess('rmbadname1: Replacing \"%s\" with \"%s\".\\n' %\n                (name, badnames[name]))\n        return badnames[name]\n    return name\n\n\ndef rmbadname(names):\n    return [rmbadname1(_m) for _m in names]\n\n\ndef undo_rmbadname1(name):\n    if name in invbadnames:\n        errmess('undo_rmbadname1: Replacing \"%s\" with \"%s\".\\n'\n                % (name, invbadnames[name]))\n        return invbadnames[name]\n    return name\n\n\ndef undo_rmbadname(names):\n    return [undo_rmbadname1(_m) for _m in names]\n\n\n_has_f_header = re.compile(r'-\\*-\\s*fortran\\s*-\\*-', re.I).search\n_has_f90_header = re.compile(r'-\\*-\\s*f90\\s*-\\*-', re.I).search\n_has_fix_header = re.compile(r'-\\*-\\s*fix\\s*-\\*-', re.I).search\n_free_f90_start = re.compile(r'[^c*]\\s*[^\\s\\d\\t]', re.I).match\n\n# Extensions\nCOMMON_FREE_EXTENSIONS = ['.f90', '.f95', '.f03', '.f08']\nCOMMON_FIXED_EXTENSIONS = ['.for', '.ftn', '.f77', '.f']\n\n\ndef openhook(filename, mode):\n    \"\"\"Ensures that filename is opened with correct encoding parameter.\n\n    This function uses charset_normalizer package, when available, for\n    determining the encoding of the file to be opened. When charset_normalizer\n    is not available, the function detects only UTF encodings, otherwise, ASCII\n    encoding is used as fallback.\n    \"\"\"\n    # Reads in the entire file. Robust detection of encoding.\n    # Correctly handles comments or late stage unicode characters\n    # gh-22871\n    if charset_normalizer is not None:\n        encoding = charset_normalizer.from_path(filename).best().encoding\n    else:\n        # hint: install charset_normalizer for correct encoding handling\n        # No need to read the whole file for trying with startswith\n        nbytes = min(32, os.path.getsize(filename))\n        with open(filename, 'rb') as fhandle:\n            raw = fhandle.read(nbytes)\n            if raw.startswith(codecs.BOM_UTF8):\n                encoding = 'UTF-8-SIG'\n            elif raw.startswith((codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE)):\n                encoding = 'UTF-32'\n            elif raw.startswith((codecs.BOM_LE, codecs.BOM_BE)):\n                encoding = 'UTF-16'\n            else:\n                # Fallback, without charset_normalizer\n                encoding = 'ascii'\n    return open(filename, mode, encoding=encoding)\n\n\ndef is_free_format(fname):\n    \"\"\"Check if file is in free format Fortran.\"\"\"\n    # f90 allows both fixed and free format, assuming fixed unless\n    # signs of free format are detected.\n    result = False\n    if Path(fname).suffix.lower() in COMMON_FREE_EXTENSIONS:\n        result = True\n    with openhook(fname, 'r') as fhandle:\n        line = fhandle.readline()\n        n = 15  # the number of non-comment lines to scan for hints\n        if _has_f_header(line):\n            n = 0\n        elif _has_f90_header(line):\n            n = 0\n            result = True\n        while n > 0 and line:\n            if line[0] != '!' and line.strip():\n                n -= 1\n                if (line[0] != '\\t' and _free_f90_start(line[:5])) or line[-2:-1] == '&':\n                    result = True\n                    break\n            line = fhandle.readline()\n    return result\n\n\n# Read fortran (77,90) code\ndef readfortrancode(ffile, dowithline=show, istop=1):\n    \"\"\"\n    Read fortran codes from files and\n     1) Get rid of comments, line continuations, and empty lines; lower cases.\n     2) Call dowithline(line) on every line.\n     3) Recursively call itself when statement \\\"include '<filename>'\\\" is met.\n    \"\"\"\n    global gotnextfile, filepositiontext, currentfilename, sourcecodeform, strictf77\n    global beginpattern, quiet, verbose, dolowercase, include_paths\n\n    if not istop:\n        saveglobals = gotnextfile, filepositiontext, currentfilename, sourcecodeform, strictf77,\\\n            beginpattern, quiet, verbose, dolowercase\n    if ffile == []:\n        return\n    localdolowercase = dolowercase\n    # cont: set to True when the content of the last line read\n    # indicates statement continuation\n    cont = False\n    finalline = ''\n    ll = ''\n    includeline = re.compile(\n        r'\\s*include\\s*(\\'|\")(?P<name>[^\\'\"]*)(\\'|\")', re.I)\n    cont1 = re.compile(r'(?P<line>.*)&\\s*\\Z')\n    cont2 = re.compile(r'(\\s*&|)(?P<line>.*)')\n    mline_mark = re.compile(r\".*?'''\")\n    if istop:\n        dowithline('', -1)\n    ll, l1 = '', ''\n    spacedigits = [' '] + [str(_m) for _m in range(10)]\n    filepositiontext = ''\n    fin = fileinput.FileInput(ffile, openhook=openhook)\n    while True:\n        try:\n            l = fin.readline()\n        except UnicodeDecodeError as msg:\n            raise Exception(\n                f'readfortrancode: reading {fin.filename()}#{fin.lineno()}'\n                f' failed with\\n{msg}.\\nIt is likely that installing charset_normalizer'\n                ' package will help f2py determine the input file encoding'\n                ' correctly.')\n        if not l:\n            break\n        if fin.isfirstline():\n            filepositiontext = ''\n            currentfilename = fin.filename()\n            gotnextfile = 1\n            l1 = l\n            strictf77 = 0\n            sourcecodeform = 'fix'\n            ext = os.path.splitext(currentfilename)[1]\n            if Path(currentfilename).suffix.lower() in COMMON_FIXED_EXTENSIONS and \\\n                    not (_has_f90_header(l) or _has_fix_header(l)):\n                strictf77 = 1\n            elif is_free_format(currentfilename) and not _has_fix_header(l):\n                sourcecodeform = 'free'\n            if strictf77:\n                beginpattern = beginpattern77\n            else:\n                beginpattern = beginpattern90\n            outmess('\\tReading file %s (format:%s%s)\\n'\n                    % (repr(currentfilename), sourcecodeform,\n                       strictf77 and ',strict' or ''))\n\n        l = l.expandtabs().replace('\\xa0', ' ')\n        # Get rid of newline characters\n        while not l == '':\n            if l[-1] not in \"\\n\\r\\f\":\n                break\n            l = l[:-1]\n        if not strictf77:\n            (l, rl) = split_by_unquoted(l, '!')\n            l += ' '\n            if rl[:5].lower() == '!f2py':  # f2py directive\n                l, _ = split_by_unquoted(l + 4 * ' ' + rl[5:], '!')\n        if l.strip() == '':  # Skip empty line\n            if sourcecodeform == 'free':\n                # In free form, a statement continues in the next line\n                # that is not a comment line [3.3.2.4^1], lines with\n                # blanks are comment lines [3.3.2.3^1]. Hence, the\n                # line continuation flag must retain its state.\n                pass\n            else:\n                # In fixed form, statement continuation is determined\n                # by a non-blank character at the 6-th position. Empty\n                # line indicates a start of a new statement\n                # [3.3.3.3^1]. Hence, the line continuation flag must\n                # be reset.\n                cont = False\n            continue\n        if sourcecodeform == 'fix':\n            if l[0] in ['*', 'c', '!', 'C', '#']:\n                if l[1:5].lower() == 'f2py':  # f2py directive\n                    l = '     ' + l[5:]\n                else:  # Skip comment line\n                    cont = False\n                    continue\n            elif strictf77:\n                if len(l) > 72:\n                    l = l[:72]\n            if not (l[0] in spacedigits):\n                raise Exception('readfortrancode: Found non-(space,digit) char '\n                                'in the first column.\\n\\tAre you sure that '\n                                'this code is in fix form?\\n\\tline=%s' % repr(l))\n\n            if (not cont or strictf77) and (len(l) > 5 and not l[5] == ' '):\n                # Continuation of a previous line\n                ll = ll + l[6:]\n                finalline = ''\n                origfinalline = ''\n            else:\n                if not strictf77:\n                    # F90 continuation\n                    r = cont1.match(l)\n                    if r:\n                        l = r.group('line')  # Continuation follows ..\n                    if cont:\n                        ll = ll + cont2.match(l).group('line')\n                        finalline = ''\n                        origfinalline = ''\n                    else:\n                        # clean up line beginning from possible digits.\n                        l = '     ' + l[5:]\n                        if localdolowercase:\n                            finalline = ll.lower()\n                        else:\n                            finalline = ll\n                        origfinalline = ll\n                        ll = l\n                    cont = (r is not None)\n                else:\n                    # clean up line beginning from possible digits.\n                    l = '     ' + l[5:]\n                    if localdolowercase:\n                        finalline = ll.lower()\n                    else:\n                        finalline = ll\n                    origfinalline = ll\n                    ll = l\n\n        elif sourcecodeform == 'free':\n            if not cont and ext == '.pyf' and mline_mark.match(l):\n                l = l + '\\n'\n                while True:\n                    lc = fin.readline()\n                    if not lc:\n                        errmess(\n                            'Unexpected end of file when reading multiline\\n')\n                        break\n                    l = l + lc\n                    if mline_mark.match(lc):\n                        break\n                l = l.rstrip()\n            r = cont1.match(l)\n            if r:\n                l = r.group('line')  # Continuation follows ..\n            if cont:\n                ll = ll + cont2.match(l).group('line')\n                finalline = ''\n                origfinalline = ''\n            else:\n                if localdolowercase:\n                    finalline = ll.lower()\n                else:\n                    finalline = ll\n                origfinalline = ll\n                ll = l\n            cont = (r is not None)\n        else:\n            raise ValueError(\n                \"Flag sourcecodeform must be either 'fix' or 'free': %s\" % repr(sourcecodeform))\n        filepositiontext = 'Line #%d in %s:\"%s\"\\n\\t' % (\n            fin.filelineno() - 1, currentfilename, l1)\n        m = includeline.match(origfinalline)\n        if m:\n            fn = m.group('name')\n            if os.path.isfile(fn):\n                readfortrancode(fn, dowithline=dowithline, istop=0)\n            else:\n                include_dirs = [\n                    os.path.dirname(currentfilename)] + include_paths\n                foundfile = 0\n                for inc_dir in include_dirs:\n                    fn1 = os.path.join(inc_dir, fn)\n                    if os.path.isfile(fn1):\n                        foundfile = 1\n                        readfortrancode(fn1, dowithline=dowithline, istop=0)\n                        break\n                if not foundfile:\n                    outmess('readfortrancode: could not find include file %s in %s. Ignoring.\\n' % (\n                        repr(fn), os.pathsep.join(include_dirs)))\n        else:\n            dowithline(finalline)\n        l1 = ll\n    if localdolowercase:\n        finalline = ll.lower()\n    else:\n        finalline = ll\n    origfinalline = ll\n    filepositiontext = 'Line #%d in %s:\"%s\"\\n\\t' % (\n        fin.filelineno() - 1, currentfilename, l1)\n    m = includeline.match(origfinalline)\n    if m:\n        fn = m.group('name')\n        if os.path.isfile(fn):\n            readfortrancode(fn, dowithline=dowithline, istop=0)\n        else:\n            include_dirs = [os.path.dirname(currentfilename)] + include_paths\n            foundfile = 0\n            for inc_dir in include_dirs:\n                fn1 = os.path.join(inc_dir, fn)\n                if os.path.isfile(fn1):\n                    foundfile = 1\n                    readfortrancode(fn1, dowithline=dowithline, istop=0)\n                    break\n            if not foundfile:\n                outmess('readfortrancode: could not find include file %s in %s. Ignoring.\\n' % (\n                    repr(fn), os.pathsep.join(include_dirs)))\n    else:\n        dowithline(finalline)\n    filepositiontext = ''\n    fin.close()\n    if istop:\n        dowithline('', 1)\n    else:\n        gotnextfile, filepositiontext, currentfilename, sourcecodeform, strictf77,\\\n            beginpattern, quiet, verbose, dolowercase = saveglobals\n\n# Crack line\nbeforethisafter = r'\\s*(?P<before>%s(?=\\s*(\\b(%s)\\b)))' + \\\n    r'\\s*(?P<this>(\\b(%s)\\b))' + \\\n    r'\\s*(?P<after>%s)\\s*\\Z'\n##\nfortrantypes = r'character|logical|integer|real|complex|double\\s*(precision\\s*(complex|)|complex)|type(?=\\s*\\([\\w\\s,=(*)]*\\))|byte'\ntypespattern = re.compile(\n    beforethisafter % ('', fortrantypes, fortrantypes, '.*'), re.I), 'type'\ntypespattern4implicit = re.compile(beforethisafter % (\n    '', fortrantypes + '|static|automatic|undefined', fortrantypes + '|static|automatic|undefined', '.*'), re.I)\n#\nfunctionpattern = re.compile(beforethisafter % (\n    r'([a-z]+[\\w\\s(=*+-/)]*?|)', 'function', 'function', '.*'), re.I), 'begin'\nsubroutinepattern = re.compile(beforethisafter % (\n    r'[a-z\\s]*?', 'subroutine', 'subroutine', '.*'), re.I), 'begin'\n# modulepattern=re.compile(beforethisafter%('[a-z\\s]*?','module','module','.*'),re.I),'begin'\n#\ngroupbegins77 = r'program|block\\s*data'\nbeginpattern77 = re.compile(\n    beforethisafter % ('', groupbegins77, groupbegins77, '.*'), re.I), 'begin'\ngroupbegins90 = groupbegins77 + \\\n    r'|module(?!\\s*procedure)|python\\s*module|(abstract|)\\s*interface|' + \\\n    r'type(?!\\s*\\()'\nbeginpattern90 = re.compile(\n    beforethisafter % ('', groupbegins90, groupbegins90, '.*'), re.I), 'begin'\ngroupends = (r'end|endprogram|endblockdata|endmodule|endpythonmodule|'\n             r'endinterface|endsubroutine|endfunction')\nendpattern = re.compile(\n    beforethisafter % ('', groupends, groupends, '.*'), re.I), 'end'\nendifs = r'end\\s*(if|do|where|select|while|forall|associate|block|' + \\\n         r'critical|enum|team)'\nendifpattern = re.compile(\n    beforethisafter % (r'[\\w]*?', endifs, endifs, '.*'), re.I), 'endif'\n#\nmoduleprocedures = r'module\\s*procedure'\nmoduleprocedurepattern = re.compile(\n    beforethisafter % ('', moduleprocedures, moduleprocedures, '.*'), re.I), \\\n    'moduleprocedure'\nimplicitpattern = re.compile(\n    beforethisafter % ('', 'implicit', 'implicit', '.*'), re.I), 'implicit'\ndimensionpattern = re.compile(beforethisafter % (\n    '', 'dimension|virtual', 'dimension|virtual', '.*'), re.I), 'dimension'\nexternalpattern = re.compile(\n    beforethisafter % ('', 'external', 'external', '.*'), re.I), 'external'\noptionalpattern = re.compile(\n    beforethisafter % ('', 'optional', 'optional', '.*'), re.I), 'optional'\nrequiredpattern = re.compile(\n    beforethisafter % ('', 'required', 'required', '.*'), re.I), 'required'\npublicpattern = re.compile(\n    beforethisafter % ('', 'public', 'public', '.*'), re.I), 'public'\nprivatepattern = re.compile(\n    beforethisafter % ('', 'private', 'private', '.*'), re.I), 'private'\nintrinsicpattern = re.compile(\n    beforethisafter % ('', 'intrinsic', 'intrinsic', '.*'), re.I), 'intrinsic'\nintentpattern = re.compile(beforethisafter % (\n    '', 'intent|depend|note|check', 'intent|depend|note|check', r'\\s*\\(.*?\\).*'), re.I), 'intent'\nparameterpattern = re.compile(\n    beforethisafter % ('', 'parameter', 'parameter', r'\\s*\\(.*'), re.I), 'parameter'\ndatapattern = re.compile(\n    beforethisafter % ('', 'data', 'data', '.*'), re.I), 'data'\ncallpattern = re.compile(\n    beforethisafter % ('', 'call', 'call', '.*'), re.I), 'call'\nentrypattern = re.compile(\n    beforethisafter % ('', 'entry', 'entry', '.*'), re.I), 'entry'\ncallfunpattern = re.compile(\n    beforethisafter % ('', 'callfun', 'callfun', '.*'), re.I), 'callfun'\ncommonpattern = re.compile(\n    beforethisafter % ('', 'common', 'common', '.*'), re.I), 'common'\nusepattern = re.compile(\n    beforethisafter % ('', 'use', 'use', '.*'), re.I), 'use'\ncontainspattern = re.compile(\n    beforethisafter % ('', 'contains', 'contains', ''), re.I), 'contains'\nformatpattern = re.compile(\n    beforethisafter % ('', 'format', 'format', '.*'), re.I), 'format'\n# Non-fortran and f2py-specific statements\nf2pyenhancementspattern = re.compile(beforethisafter % ('', 'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef',\n                                                        'threadsafe|fortranname|callstatement|callprotoargument|usercode|pymethoddef', '.*'), re.I | re.S), 'f2pyenhancements'\nmultilinepattern = re.compile(\n    r\"\\s*(?P<before>''')(?P<this>.*?)(?P<after>''')\\s*\\Z\", re.S), 'multiline'\n##\n\ndef split_by_unquoted(line, characters):\n    \"\"\"\n    Splits the line into (line[:i], line[i:]),\n    where i is the index of first occurrence of one of the characters\n    not within quotes, or len(line) if no such index exists\n    \"\"\"\n    assert not (set('\"\\'') & set(characters)), \"cannot split by unquoted quotes\"\n    r = re.compile(\n        r\"\\A(?P<before>({single_quoted}|{double_quoted}|{not_quoted})*)\"\n        r\"(?P<after>{char}.*)\\Z\".format(\n            not_quoted=\"[^\\\"'{}]\".format(re.escape(characters)),\n            char=\"[{}]\".format(re.escape(characters)),\n            single_quoted=r\"('([^'\\\\]|(\\\\.))*')\",\n            double_quoted=r'(\"([^\"\\\\]|(\\\\.))*\")'))\n    m = r.match(line)\n    if m:\n        d = m.groupdict()\n        return (d[\"before\"], d[\"after\"])\n    return (line, \"\")\n\ndef _simplifyargs(argsline):\n    a = []\n    for n in markoutercomma(argsline).split('@,@'):\n        for r in '(),':\n            n = n.replace(r, '_')\n        a.append(n)\n    return ','.join(a)\n\ncrackline_re_1 = re.compile(r'\\s*(?P<result>\\b[a-z]+\\w*\\b)\\s*=.*', re.I)\n\n\ndef crackline(line, reset=0):\n    \"\"\"\n    reset=-1  --- initialize\n    reset=0   --- crack the line\n    reset=1   --- final check if mismatch of blocks occurred\n\n    Cracked data is saved in grouplist[0].\n    \"\"\"\n    global beginpattern, groupcounter, groupname, groupcache, grouplist\n    global filepositiontext, currentfilename, neededmodule, expectbegin\n    global skipblocksuntil, skipemptyends, previous_context, gotnextfile\n\n    _, has_semicolon = split_by_unquoted(line, \";\")\n    if has_semicolon and not (f2pyenhancementspattern[0].match(line) or\n                               multilinepattern[0].match(line)):\n        # XXX: non-zero reset values need testing\n        assert reset == 0, repr(reset)\n        # split line on unquoted semicolons\n        line, semicolon_line = split_by_unquoted(line, \";\")\n        while semicolon_line:\n            crackline(line, reset)\n            line, semicolon_line = split_by_unquoted(semicolon_line[1:], \";\")\n        crackline(line, reset)\n        return\n    if reset < 0:\n        groupcounter = 0\n        groupname = {groupcounter: ''}\n        groupcache = {groupcounter: {}}\n        grouplist = {groupcounter: []}\n        groupcache[groupcounter]['body'] = []\n        groupcache[groupcounter]['vars'] = {}\n        groupcache[groupcounter]['block'] = ''\n        groupcache[groupcounter]['name'] = ''\n        neededmodule = -1\n        skipblocksuntil = -1\n        return\n    if reset > 0:\n        fl = 0\n        if f77modulename and neededmodule == groupcounter:\n            fl = 2\n        while groupcounter > fl:\n            outmess('crackline: groupcounter=%s groupname=%s\\n' %\n                    (repr(groupcounter), repr(groupname)))\n            outmess(\n                'crackline: Mismatch of blocks encountered. Trying to fix it by assuming \"end\" statement.\\n')\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1\n        if f77modulename and neededmodule == groupcounter:\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1  # end interface\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1  # end module\n            neededmodule = -1\n        return\n    if line == '':\n        return\n    flag = 0\n    for pat in [dimensionpattern, externalpattern, intentpattern, optionalpattern,\n                requiredpattern,\n                parameterpattern, datapattern, publicpattern, privatepattern,\n                intrinsicpattern,\n                endifpattern, endpattern,\n                formatpattern,\n                beginpattern, functionpattern, subroutinepattern,\n                implicitpattern, typespattern, commonpattern,\n                callpattern, usepattern, containspattern,\n                entrypattern,\n                f2pyenhancementspattern,\n                multilinepattern,\n                moduleprocedurepattern\n                ]:\n        m = pat[0].match(line)\n        if m:\n            break\n        flag = flag + 1\n    if not m:\n        re_1 = crackline_re_1\n        if 0 <= skipblocksuntil <= groupcounter:\n            return\n        if 'externals' in groupcache[groupcounter]:\n            for name in groupcache[groupcounter]['externals']:\n                if name in invbadnames:\n                    name = invbadnames[name]\n                if 'interfaced' in groupcache[groupcounter] and name in groupcache[groupcounter]['interfaced']:\n                    continue\n                m1 = re.match(\n                    r'(?P<before>[^\"]*)\\b%s\\b\\s*@\\(@(?P<args>[^@]*)@\\)@.*\\Z' % name, markouterparen(line), re.I)\n                if m1:\n                    m2 = re_1.match(m1.group('before'))\n                    a = _simplifyargs(m1.group('args'))\n                    if m2:\n                        line = 'callfun %s(%s) result (%s)' % (\n                            name, a, m2.group('result'))\n                    else:\n                        line = 'callfun %s(%s)' % (name, a)\n                    m = callfunpattern[0].match(line)\n                    if not m:\n                        outmess(\n                            'crackline: could not resolve function call for line=%s.\\n' % repr(line))\n                        return\n                    analyzeline(m, 'callfun', line)\n                    return\n        if verbose > 1 or (verbose == 1 and currentfilename.lower().endswith('.pyf')):\n            previous_context = None\n            outmess('crackline:%d: No pattern for line\\n' % (groupcounter))\n        return\n    elif pat[1] == 'end':\n        if 0 <= skipblocksuntil < groupcounter:\n            groupcounter = groupcounter - 1\n            if skipblocksuntil <= groupcounter:\n                return\n        if groupcounter <= 0:\n            raise Exception('crackline: groupcounter(=%s) is nonpositive. '\n                            'Check the blocks.'\n                            % (groupcounter))\n        m1 = beginpattern[0].match((line))\n        if (m1) and (not m1.group('this') == groupname[groupcounter]):\n            raise Exception('crackline: End group %s does not match with '\n                            'previous Begin group %s\\n\\t%s' %\n                            (repr(m1.group('this')), repr(groupname[groupcounter]),\n                             filepositiontext)\n                            )\n        if skipblocksuntil == groupcounter:\n            skipblocksuntil = -1\n        grouplist[groupcounter - 1].append(groupcache[groupcounter])\n        grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n        del grouplist[groupcounter]\n        groupcounter = groupcounter - 1\n        if not skipemptyends:\n            expectbegin = 1\n    elif pat[1] == 'begin':\n        if 0 <= skipblocksuntil <= groupcounter:\n            groupcounter = groupcounter + 1\n            return\n        gotnextfile = 0\n        analyzeline(m, pat[1], line)\n        expectbegin = 0\n    elif pat[1] == 'endif':\n        pass\n    elif pat[1] == 'moduleprocedure':\n        analyzeline(m, pat[1], line)\n    elif pat[1] == 'contains':\n        if ignorecontains:\n            return\n        if 0 <= skipblocksuntil <= groupcounter:\n            return\n        skipblocksuntil = groupcounter\n    else:\n        if 0 <= skipblocksuntil <= groupcounter:\n            return\n        analyzeline(m, pat[1], line)\n\n\ndef markouterparen(line):\n    l = ''\n    f = 0\n    for c in line:\n        if c == '(':\n            f = f + 1\n            if f == 1:\n                l = l + '@(@'\n                continue\n        elif c == ')':\n            f = f - 1\n            if f == 0:\n                l = l + '@)@'\n                continue\n        l = l + c\n    return l\n\n\ndef markoutercomma(line, comma=','):\n    l = ''\n    f = 0\n    before, after = split_by_unquoted(line, comma + '()')\n    l += before\n    while after:\n        if (after[0] == comma) and (f == 0):\n            l += '@' + comma + '@'\n        else:\n            l += after[0]\n            if after[0] == '(':\n                f += 1\n            elif after[0] == ')':\n                f -= 1\n        before, after = split_by_unquoted(after[1:], comma + '()')\n        l += before\n    assert not f, repr((f, line, l))\n    return l\n\ndef unmarkouterparen(line):\n    r = line.replace('@(@', '(').replace('@)@', ')')\n    return r\n\n\ndef appenddecl(decl, decl2, force=1):\n    if not decl:\n        decl = {}\n    if not decl2:\n        return decl\n    if decl is decl2:\n        return decl\n    for k in list(decl2.keys()):\n        if k == 'typespec':\n            if force or k not in decl:\n                decl[k] = decl2[k]\n        elif k == 'attrspec':\n            for l in decl2[k]:\n                decl = setattrspec(decl, l, force)\n        elif k == 'kindselector':\n            decl = setkindselector(decl, decl2[k], force)\n        elif k == 'charselector':\n            decl = setcharselector(decl, decl2[k], force)\n        elif k in ['=', 'typename']:\n            if force or k not in decl:\n                decl[k] = decl2[k]\n        elif k == 'note':\n            pass\n        elif k in ['intent', 'check', 'dimension', 'optional',\n                   'required', 'depend']:\n            errmess('appenddecl: \"%s\" not implemented.\\n' % k)\n        else:\n            raise Exception('appenddecl: Unknown variable definition key: ' +\n                            str(k))\n    return decl\n\nselectpattern = re.compile(\n    r'\\s*(?P<this>(@\\(@.*?@\\)@|\\*[\\d*]+|\\*\\s*@\\(@.*?@\\)@|))(?P<after>.*)\\Z', re.I)\ntypedefpattern = re.compile(\n    r'(?:,(?P<attributes>[\\w(),]+))?(::)?(?P<name>\\b[a-z$_][\\w$]*\\b)'\n    r'(?:\\((?P<params>[\\w,]*)\\))?\\Z', re.I)\nnameargspattern = re.compile(\n    r'\\s*(?P<name>\\b[\\w$]+\\b)\\s*(@\\(@\\s*(?P<args>[\\w\\s,]*)\\s*@\\)@|)\\s*((result(\\s*@\\(@\\s*(?P<result>\\b[\\w$]+\\b)\\s*@\\)@|))|(bind\\s*@\\(@\\s*(?P<bind>(?:(?!@\\)@).)*)\\s*@\\)@))*\\s*\\Z', re.I)\noperatorpattern = re.compile(\n    r'\\s*(?P<scheme>(operator|assignment))'\n    r'@\\(@\\s*(?P<name>[^)]+)\\s*@\\)@\\s*\\Z', re.I)\ncallnameargspattern = re.compile(\n    r'\\s*(?P<name>\\b[\\w$]+\\b)\\s*@\\(@\\s*(?P<args>.*)\\s*@\\)@\\s*\\Z', re.I)\nreal16pattern = re.compile(\n    r'([-+]?(?:\\d+(?:\\.\\d*)?|\\d*\\.\\d+))[dD]((?:[-+]?\\d+)?)')\nreal8pattern = re.compile(\n    r'([-+]?((?:\\d+(?:\\.\\d*)?|\\d*\\.\\d+))[eE]((?:[-+]?\\d+)?)|(\\d+\\.\\d*))')\n\n_intentcallbackpattern = re.compile(r'intent\\s*\\(.*?\\bcallback\\b', re.I)\n\n\ndef _is_intent_callback(vdecl):\n    for a in vdecl.get('attrspec', []):\n        if _intentcallbackpattern.match(a):\n            return 1\n    return 0\n\n\ndef _resolvetypedefpattern(line):\n    line = ''.join(line.split())  # removes whitespace\n    m1 = typedefpattern.match(line)\n    print(line, m1)\n    if m1:\n        attrs = m1.group('attributes')\n        attrs = [a.lower() for a in attrs.split(',')] if attrs else []\n        return m1.group('name'), attrs, m1.group('params')\n    return None, [], None\n\n\ndef _resolvenameargspattern(line):\n    line = markouterparen(line)\n    m1 = nameargspattern.match(line)\n    if m1:\n        return m1.group('name'), m1.group('args'), m1.group('result'), m1.group('bind')\n    m1 = operatorpattern.match(line)\n    if m1:\n        name = m1.group('scheme') + '(' + m1.group('name') + ')'\n        return name, [], None, None\n    m1 = callnameargspattern.match(line)\n    if m1:\n        return m1.group('name'), m1.group('args'), None, None\n    return None, [], None, None\n\n\ndef analyzeline(m, case, line):\n    global groupcounter, groupname, groupcache, grouplist, filepositiontext\n    global currentfilename, f77modulename, neededinterface, neededmodule\n    global expectbegin, gotnextfile, previous_context\n\n    block = m.group('this')\n    if case != 'multiline':\n        previous_context = None\n    if expectbegin and case not in ['begin', 'call', 'callfun', 'type'] \\\n       and not skipemptyends and groupcounter < 1:\n        newname = os.path.basename(currentfilename).split('.')[0]\n        outmess(\n            'analyzeline: no group yet. Creating program group with name \"%s\".\\n' % newname)\n        gotnextfile = 0\n        groupcounter = groupcounter + 1\n        groupname[groupcounter] = 'program'\n        groupcache[groupcounter] = {}\n        grouplist[groupcounter] = []\n        groupcache[groupcounter]['body'] = []\n        groupcache[groupcounter]['vars'] = {}\n        groupcache[groupcounter]['block'] = 'program'\n        groupcache[groupcounter]['name'] = newname\n        groupcache[groupcounter]['from'] = 'fromsky'\n        expectbegin = 0\n    if case in ['begin', 'call', 'callfun']:\n        # Crack line => block,name,args,result\n        block = block.lower()\n        if re.match(r'block\\s*data', block, re.I):\n            block = 'block data'\n        elif re.match(r'python\\s*module', block, re.I):\n            block = 'python module'\n        elif re.match(r'abstract\\s*interface', block, re.I):\n            block = 'abstract interface'\n        if block == 'type':\n            name, attrs, _ = _resolvetypedefpattern(m.group('after'))\n            groupcache[groupcounter]['vars'][name] = dict(attrspec = attrs)\n            args = []\n            result = None\n        else:\n            name, args, result, _ = _resolvenameargspattern(m.group('after'))\n        if name is None:\n            if block == 'block data':\n                name = '_BLOCK_DATA_'\n            else:\n                name = ''\n            if block not in ['interface', 'block data', 'abstract interface']:\n                outmess('analyzeline: No name/args pattern found for line.\\n')\n\n        previous_context = (block, name, groupcounter)\n        if args:\n            args = rmbadname([x.strip()\n                              for x in markoutercomma(args).split('@,@')])\n        else:\n            args = []\n        if '' in args:\n            while '' in args:\n                args.remove('')\n            outmess(\n                'analyzeline: argument list is malformed (missing argument).\\n')\n\n        # end of crack line => block,name,args,result\n        needmodule = 0\n        needinterface = 0\n\n        if case in ['call', 'callfun']:\n            needinterface = 1\n            if 'args' not in groupcache[groupcounter]:\n                return\n            if name not in groupcache[groupcounter]['args']:\n                return\n            for it in grouplist[groupcounter]:\n                if it['name'] == name:\n                    return\n            if name in groupcache[groupcounter]['interfaced']:\n                return\n            block = {'call': 'subroutine', 'callfun': 'function'}[case]\n        if f77modulename and neededmodule == -1 and groupcounter <= 1:\n            neededmodule = groupcounter + 2\n            needmodule = 1\n            if block not in ['interface', 'abstract interface']:\n                needinterface = 1\n        # Create new block(s)\n        groupcounter = groupcounter + 1\n        groupcache[groupcounter] = {}\n        grouplist[groupcounter] = []\n        if needmodule:\n            if verbose > 1:\n                outmess('analyzeline: Creating module block %s\\n' %\n                        repr(f77modulename), 0)\n            groupname[groupcounter] = 'module'\n            groupcache[groupcounter]['block'] = 'python module'\n            groupcache[groupcounter]['name'] = f77modulename\n            groupcache[groupcounter]['from'] = ''\n            groupcache[groupcounter]['body'] = []\n            groupcache[groupcounter]['externals'] = []\n            groupcache[groupcounter]['interfaced'] = []\n            groupcache[groupcounter]['vars'] = {}\n            groupcounter = groupcounter + 1\n            groupcache[groupcounter] = {}\n            grouplist[groupcounter] = []\n        if needinterface:\n            if verbose > 1:\n                outmess('analyzeline: Creating additional interface block (groupcounter=%s).\\n' % (\n                    groupcounter), 0)\n            groupname[groupcounter] = 'interface'\n            groupcache[groupcounter]['block'] = 'interface'\n            groupcache[groupcounter]['name'] = 'unknown_interface'\n            groupcache[groupcounter]['from'] = '%s:%s' % (\n                groupcache[groupcounter - 1]['from'], groupcache[groupcounter - 1]['name'])\n            groupcache[groupcounter]['body'] = []\n            groupcache[groupcounter]['externals'] = []\n            groupcache[groupcounter]['interfaced'] = []\n            groupcache[groupcounter]['vars'] = {}\n            groupcounter = groupcounter + 1\n            groupcache[groupcounter] = {}\n            grouplist[groupcounter] = []\n        groupname[groupcounter] = block\n        groupcache[groupcounter]['block'] = block\n        if not name:\n            name = 'unknown_' + block.replace(' ', '_')\n        groupcache[groupcounter]['prefix'] = m.group('before')\n        groupcache[groupcounter]['name'] = rmbadname1(name)\n        groupcache[groupcounter]['result'] = result\n        if groupcounter == 1:\n            groupcache[groupcounter]['from'] = currentfilename\n        else:\n            if f77modulename and groupcounter == 3:\n                groupcache[groupcounter]['from'] = '%s:%s' % (\n                    groupcache[groupcounter - 1]['from'], currentfilename)\n            else:\n                groupcache[groupcounter]['from'] = '%s:%s' % (\n                    groupcache[groupcounter - 1]['from'], groupcache[groupcounter - 1]['name'])\n        for k in list(groupcache[groupcounter].keys()):\n            if not groupcache[groupcounter][k]:\n                del groupcache[groupcounter][k]\n\n        groupcache[groupcounter]['args'] = args\n        groupcache[groupcounter]['body'] = []\n        groupcache[groupcounter]['externals'] = []\n        groupcache[groupcounter]['interfaced'] = []\n        groupcache[groupcounter]['vars'] = {}\n        groupcache[groupcounter]['entry'] = {}\n        # end of creation\n        if block == 'type':\n            groupcache[groupcounter]['varnames'] = []\n\n        if case in ['call', 'callfun']:  # set parents variables\n            if name not in groupcache[groupcounter - 2]['externals']:\n                groupcache[groupcounter - 2]['externals'].append(name)\n            groupcache[groupcounter]['vars'] = copy.deepcopy(\n                groupcache[groupcounter - 2]['vars'])\n            try:\n                del groupcache[groupcounter]['vars'][name][\n                    groupcache[groupcounter]['vars'][name]['attrspec'].index('external')]\n            except Exception:\n                pass\n        if block in ['function', 'subroutine']:  # set global attributes\n            try:\n                groupcache[groupcounter]['vars'][name] = appenddecl(\n                    groupcache[groupcounter]['vars'][name], groupcache[groupcounter - 2]['vars'][''])\n            except Exception:\n                pass\n            if case == 'callfun':  # return type\n                if result and result in groupcache[groupcounter]['vars']:\n                    if not name == result:\n                        groupcache[groupcounter]['vars'][name] = appenddecl(\n                            groupcache[groupcounter]['vars'][name], groupcache[groupcounter]['vars'][result])\n            # if groupcounter>1: # name is interfaced\n            try:\n                groupcache[groupcounter - 2]['interfaced'].append(name)\n            except Exception:\n                pass\n        if block == 'function':\n            t = typespattern[0].match(m.group('before') + ' ' + name)\n            if t:\n                typespec, selector, attr, edecl = cracktypespec0(\n                    t.group('this'), t.group('after'))\n                updatevars(typespec, selector, attr, edecl)\n\n        if case in ['call', 'callfun']:\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1  # end routine\n            grouplist[groupcounter - 1].append(groupcache[groupcounter])\n            grouplist[groupcounter - 1][-1]['body'] = grouplist[groupcounter]\n            del grouplist[groupcounter]\n            groupcounter = groupcounter - 1  # end interface\n\n    elif case == 'entry':\n        name, args, result, bind = _resolvenameargspattern(m.group('after'))\n        if name is not None:\n            if args:\n                args = rmbadname([x.strip()\n                                  for x in markoutercomma(args).split('@,@')])\n            else:\n                args = []\n            assert result is None, repr(result)\n            groupcache[groupcounter]['entry'][name] = args\n            previous_context = ('entry', name, groupcounter)\n    elif case == 'type':\n        typespec, selector, attr, edecl = cracktypespec0(\n            block, m.group('after'))\n        last_name = updatevars(typespec, selector, attr, edecl)\n        if last_name is not None:\n            previous_context = ('variable', last_name, groupcounter)\n    elif case in ['dimension', 'intent', 'optional', 'required', 'external', 'public', 'private', 'intrinsic']:\n        edecl = groupcache[groupcounter]['vars']\n        ll = m.group('after').strip()\n        i = ll.find('::')\n        if i < 0 and case == 'intent':\n            i = markouterparen(ll).find('@)@') - 2\n            ll = ll[:i + 1] + '::' + ll[i + 1:]\n            i = ll.find('::')\n            if ll[i:] == '::' and 'args' in groupcache[groupcounter]:\n                outmess('All arguments will have attribute %s%s\\n' %\n                        (m.group('this'), ll[:i]))\n                ll = ll + ','.join(groupcache[groupcounter]['args'])\n        if i < 0:\n            i = 0\n            pl = ''\n        else:\n            pl = ll[:i].strip()\n            ll = ll[i + 2:]\n        ch = markoutercomma(pl).split('@,@')\n        if len(ch) > 1:\n            pl = ch[0]\n            outmess('analyzeline: cannot handle multiple attributes without type specification. Ignoring %r.\\n' % (\n                ','.join(ch[1:])))\n        last_name = None\n\n        for e in [x.strip() for x in markoutercomma(ll).split('@,@')]:\n            m1 = namepattern.match(e)\n            if not m1:\n                if case in ['public', 'private']:\n                    k = ''\n                else:\n                    print(m.groupdict())\n                    outmess('analyzeline: no name pattern found in %s statement for %s. Skipping.\\n' % (\n                        case, repr(e)))\n                    continue\n            else:\n                k = rmbadname1(m1.group('name'))\n            if case in ['public', 'private'] and \\\n               (k == 'operator' or k == 'assignment'):\n                k += m1.group('after')\n            if k not in edecl:\n                edecl[k] = {}\n            if case == 'dimension':\n                ap = case + m1.group('after')\n            if case == 'intent':\n                ap = m.group('this') + pl\n                if _intentcallbackpattern.match(ap):\n                    if k not in groupcache[groupcounter]['args']:\n                        if groupcounter > 1:\n                            if '__user__' not in groupcache[groupcounter - 2]['name']:\n                                outmess(\n                                    'analyzeline: missing __user__ module (could be nothing)\\n')\n                            # fixes ticket 1693\n                            if k != groupcache[groupcounter]['name']:\n                                outmess('analyzeline: appending intent(callback) %s'\n                                        ' to %s arguments\\n' % (k, groupcache[groupcounter]['name']))\n                                groupcache[groupcounter]['args'].append(k)\n                        else:\n                            errmess(\n                                'analyzeline: intent(callback) %s is ignored\\n' % (k))\n                    else:\n                        errmess('analyzeline: intent(callback) %s is already'\n                                ' in argument list\\n' % (k))\n            if case in ['optional', 'required', 'public', 'external', 'private', 'intrinsic']:\n                ap = case\n            if 'attrspec' in edecl[k]:\n                edecl[k]['attrspec'].append(ap)\n            else:\n                edecl[k]['attrspec'] = [ap]\n            if case == 'external':\n                if groupcache[groupcounter]['block'] == 'program':\n                    outmess('analyzeline: ignoring program arguments\\n')\n                    continue\n                if k not in groupcache[groupcounter]['args']:\n                    continue\n                if 'externals' not in groupcache[groupcounter]:\n                    groupcache[groupcounter]['externals'] = []\n                groupcache[groupcounter]['externals'].append(k)\n            last_name = k\n        groupcache[groupcounter]['vars'] = edecl\n        if last_name is not None:\n            previous_context = ('variable', last_name, groupcounter)\n    elif case == 'moduleprocedure':\n        groupcache[groupcounter]['implementedby'] = \\\n            [x.strip() for x in m.group('after').split(',')]\n    elif case == 'parameter':\n        edecl = groupcache[groupcounter]['vars']\n        ll = m.group('after').strip()[1:-1]\n        last_name = None\n        for e in markoutercomma(ll).split('@,@'):\n            try:\n                k, initexpr = [x.strip() for x in e.split('=')]\n            except Exception:\n                outmess(\n                    'analyzeline: could not extract name,expr in parameter statement \"%s\" of \"%s\"\\n' % (e, ll))\n                continue\n            params = get_parameters(edecl)\n            k = rmbadname1(k)\n            if k not in edecl:\n                edecl[k] = {}\n            if '=' in edecl[k] and (not edecl[k]['='] == initexpr):\n                outmess('analyzeline: Overwriting the value of parameter \"%s\" (\"%s\") with \"%s\".\\n' % (\n                    k, edecl[k]['='], initexpr))\n            t = determineexprtype(initexpr, params)\n            if t:\n                if t.get('typespec') == 'real':\n                    tt = list(initexpr)\n                    for m in real16pattern.finditer(initexpr):\n                        tt[m.start():m.end()] = list(\n                            initexpr[m.start():m.end()].lower().replace('d', 'e'))\n                    initexpr = ''.join(tt)\n                elif t.get('typespec') == 'complex':\n                    initexpr = initexpr[1:].lower().replace('d', 'e').\\\n                        replace(',', '+1j*(')\n            try:\n                v = eval(initexpr, {}, params)\n            except (SyntaxError, NameError, TypeError) as msg:\n                errmess('analyzeline: Failed to evaluate %r. Ignoring: %s\\n'\n                        % (initexpr, msg))\n                continue\n            edecl[k]['='] = repr(v)\n            if 'attrspec' in edecl[k]:\n                edecl[k]['attrspec'].append('parameter')\n            else:\n                edecl[k]['attrspec'] = ['parameter']\n            last_name = k\n        groupcache[groupcounter]['vars'] = edecl\n        if last_name is not None:\n            previous_context = ('variable', last_name, groupcounter)\n    elif case == 'implicit':\n        if m.group('after').strip().lower() == 'none':\n            groupcache[groupcounter]['implicit'] = None\n        elif m.group('after'):\n            if 'implicit' in groupcache[groupcounter]:\n                impl = groupcache[groupcounter]['implicit']\n            else:\n                impl = {}\n            if impl is None:\n                outmess(\n                    'analyzeline: Overwriting earlier \"implicit none\" statement.\\n')\n                impl = {}\n            for e in markoutercomma(m.group('after')).split('@,@'):\n                decl = {}\n                m1 = re.match(\n                    r'\\s*(?P<this>.*?)\\s*(\\(\\s*(?P<after>[a-z-, ]+)\\s*\\)\\s*|)\\Z', e, re.I)\n                if not m1:\n                    outmess(\n                        'analyzeline: could not extract info of implicit statement part \"%s\"\\n' % (e))\n                    continue\n                m2 = typespattern4implicit.match(m1.group('this'))\n                if not m2:\n                    outmess(\n                        'analyzeline: could not extract types pattern of implicit statement part \"%s\"\\n' % (e))\n                    continue\n                typespec, selector, attr, edecl = cracktypespec0(\n                    m2.group('this'), m2.group('after'))\n                kindselect, charselect, typename = cracktypespec(\n                    typespec, selector)\n                decl['typespec'] = typespec\n                decl['kindselector'] = kindselect\n                decl['charselector'] = charselect\n                decl['typename'] = typename\n                for k in list(decl.keys()):\n                    if not decl[k]:\n                        del decl[k]\n                for r in markoutercomma(m1.group('after')).split('@,@'):\n                    if '-' in r:\n                        try:\n                            begc, endc = [x.strip() for x in r.split('-')]\n                        except Exception:\n                            outmess(\n                                'analyzeline: expected \"<char>-<char>\" instead of \"%s\" in range list of implicit statement\\n' % r)\n                            continue\n                    else:\n                        begc = endc = r.strip()\n                    if not len(begc) == len(endc) == 1:\n                        outmess(\n                            'analyzeline: expected \"<char>-<char>\" instead of \"%s\" in range list of implicit statement (2)\\n' % r)\n                        continue\n                    for o in range(ord(begc), ord(endc) + 1):\n                        impl[chr(o)] = decl\n            groupcache[groupcounter]['implicit'] = impl\n    elif case == 'data':\n        ll = []\n        dl = ''\n        il = ''\n        f = 0\n        fc = 1\n        inp = 0\n        for c in m.group('after'):\n            if not inp:\n                if c == \"'\":\n                    fc = not fc\n                if c == '/' and fc:\n                    f = f + 1\n                    continue\n            if c == '(':\n                inp = inp + 1\n            elif c == ')':\n                inp = inp - 1\n            if f == 0:\n                dl = dl + c\n            elif f == 1:\n                il = il + c\n            elif f == 2:\n                dl = dl.strip()\n                if dl.startswith(','):\n                    dl = dl[1:].strip()\n                ll.append([dl, il])\n                dl = c\n                il = ''\n                f = 0\n        if f == 2:\n            dl = dl.strip()\n            if dl.startswith(','):\n                dl = dl[1:].strip()\n            ll.append([dl, il])\n        vars = {}\n        if 'vars' in groupcache[groupcounter]:\n            vars = groupcache[groupcounter]['vars']\n        last_name = None\n        for l in ll:\n            l = [x.strip() for x in l]\n            if l[0][0] == ',':\n                l[0] = l[0][1:]\n            if l[0][0] == '(':\n                outmess(\n                    'analyzeline: implied-DO list \"%s\" is not supported. Skipping.\\n' % l[0])\n                continue\n            i = 0\n            j = 0\n            llen = len(l[1])\n            for v in rmbadname([x.strip() for x in markoutercomma(l[0]).split('@,@')]):\n                if v[0] == '(':\n                    outmess(\n                        'analyzeline: implied-DO list \"%s\" is not supported. Skipping.\\n' % v)\n                    # XXX: subsequent init expressions may get wrong values.\n                    # Ignoring since data statements are irrelevant for\n                    # wrapping.\n                    continue\n                fc = 0\n                while (i < llen) and (fc or not l[1][i] == ','):\n                    if l[1][i] == \"'\":\n                        fc = not fc\n                    i = i + 1\n                i = i + 1\n                if v not in vars:\n                    vars[v] = {}\n                if '=' in vars[v] and not vars[v]['='] == l[1][j:i - 1]:\n                    outmess('analyzeline: changing init expression of \"%s\" (\"%s\") to \"%s\"\\n' % (\n                        v, vars[v]['='], l[1][j:i - 1]))\n                vars[v]['='] = l[1][j:i - 1]\n                j = i\n                last_name = v\n        groupcache[groupcounter]['vars'] = vars\n        if last_name is not None:\n            previous_context = ('variable', last_name, groupcounter)\n    elif case == 'common':\n        line = m.group('after').strip()\n        if not line[0] == '/':\n            line = '//' + line\n        cl = []\n        f = 0\n        bn = ''\n        ol = ''\n        for c in line:\n            if c == '/':\n                f = f + 1\n                continue\n            if f >= 3:\n                bn = bn.strip()\n                if not bn:\n                    bn = '_BLNK_'\n                cl.append([bn, ol])\n                f = f - 2\n                bn = ''\n                ol = ''\n            if f % 2:\n                bn = bn + c\n            else:\n                ol = ol + c\n        bn = bn.strip()\n        if not bn:\n            bn = '_BLNK_'\n        cl.append([bn, ol])\n        commonkey = {}\n        if 'common' in groupcache[groupcounter]:\n            commonkey = groupcache[groupcounter]['common']\n        for c in cl:\n            if c[0] not in commonkey:\n                commonkey[c[0]] = []\n            for i in [x.strip() for x in markoutercomma(c[1]).split('@,@')]:\n                if i:\n                    commonkey[c[0]].append(i)\n        groupcache[groupcounter]['common'] = commonkey\n        previous_context = ('common', bn, groupcounter)\n    elif case == 'use':\n        m1 = re.match(\n            r'\\A\\s*(?P<name>\\b\\w+\\b)\\s*((,(\\s*\\bonly\\b\\s*:|(?P<notonly>))\\s*(?P<list>.*))|)\\s*\\Z', m.group('after'), re.I)\n        if m1:\n            mm = m1.groupdict()\n            if 'use' not in groupcache[groupcounter]:\n                groupcache[groupcounter]['use'] = {}\n            name = m1.group('name')\n            groupcache[groupcounter]['use'][name] = {}\n            isonly = 0\n            if 'list' in mm and mm['list'] is not None:\n                if 'notonly' in mm and mm['notonly'] is None:\n                    isonly = 1\n                groupcache[groupcounter]['use'][name]['only'] = isonly\n                ll = [x.strip() for x in mm['list'].split(',')]\n                rl = {}\n                for l in ll:\n                    if '=' in l:\n                        m2 = re.match(\n                            r'\\A\\s*(?P<local>\\b\\w+\\b)\\s*=\\s*>\\s*(?P<use>\\b\\w+\\b)\\s*\\Z', l, re.I)\n                        if m2:\n                            rl[m2.group('local').strip()] = m2.group(\n                                'use').strip()\n                        else:\n                            outmess(\n                                'analyzeline: Not local=>use pattern found in %s\\n' % repr(l))\n                    else:\n                        rl[l] = l\n                    groupcache[groupcounter]['use'][name]['map'] = rl\n            else:\n                pass\n        else:\n            print(m.groupdict())\n            outmess('analyzeline: Could not crack the use statement.\\n')\n    elif case in ['f2pyenhancements']:\n        if 'f2pyenhancements' not in groupcache[groupcounter]:\n            groupcache[groupcounter]['f2pyenhancements'] = {}\n        d = groupcache[groupcounter]['f2pyenhancements']\n        if m.group('this') == 'usercode' and 'usercode' in d:\n            if isinstance(d['usercode'], str):\n                d['usercode'] = [d['usercode']]\n            d['usercode'].append(m.group('after'))\n        else:\n            d[m.group('this')] = m.group('after')\n    elif case == 'multiline':\n        if previous_context is None:\n            if verbose:\n                outmess('analyzeline: No context for multiline block.\\n')\n            return\n        gc = groupcounter\n        appendmultiline(groupcache[gc],\n                        previous_context[:2],\n                        m.group('this'))\n    else:\n        if verbose > 1:\n            print(m.groupdict())\n            outmess('analyzeline: No code implemented for line.\\n')\n\n\ndef appendmultiline(group, context_name, ml):\n    if 'f2pymultilines' not in group:\n        group['f2pymultilines'] = {}\n    d = group['f2pymultilines']\n    if context_name not in d:\n        d[context_name] = []\n    d[context_name].append(ml)\n    return\n\n\ndef cracktypespec0(typespec, ll):\n    selector = None\n    attr = None\n    if re.match(r'double\\s*complex', typespec, re.I):\n        typespec = 'double complex'\n    elif re.match(r'double\\s*precision', typespec, re.I):\n        typespec = 'double precision'\n    else:\n        typespec = typespec.strip().lower()\n    m1 = selectpattern.match(markouterparen(ll))\n    if not m1:\n        outmess(\n            'cracktypespec0: no kind/char_selector pattern found for line.\\n')\n        return\n    d = m1.groupdict()\n    for k in list(d.keys()):\n        d[k] = unmarkouterparen(d[k])\n    if typespec in ['complex', 'integer', 'logical', 'real', 'character', 'type']:\n        selector = d['this']\n        ll = d['after']\n    i = ll.find('::')\n    if i >= 0:\n        attr = ll[:i].strip()\n        ll = ll[i + 2:]\n    return typespec, selector, attr, ll\n#####\nnamepattern = re.compile(r'\\s*(?P<name>\\b\\w+\\b)\\s*(?P<after>.*)\\s*\\Z', re.I)\nkindselector = re.compile(\n    r'\\s*(\\(\\s*(kind\\s*=)?\\s*(?P<kind>.*)\\s*\\)|\\*\\s*(?P<kind2>.*?))\\s*\\Z', re.I)\ncharselector = re.compile(\n    r'\\s*(\\((?P<lenkind>.*)\\)|\\*\\s*(?P<charlen>.*))\\s*\\Z', re.I)\nlenkindpattern = re.compile(\n    r'\\s*(kind\\s*=\\s*(?P<kind>.*?)\\s*(@,@\\s*len\\s*=\\s*(?P<len>.*)|)'\n    r'|(len\\s*=\\s*|)(?P<len2>.*?)\\s*(@,@\\s*(kind\\s*=\\s*|)(?P<kind2>.*)'\n    r'|(f2py_len\\s*=\\s*(?P<f2py_len>.*))|))\\s*\\Z', re.I)\nlenarraypattern = re.compile(\n    r'\\s*(@\\(@\\s*(?!/)\\s*(?P<array>.*?)\\s*@\\)@\\s*\\*\\s*(?P<len>.*?)|(\\*\\s*(?P<len2>.*?)|)\\s*(@\\(@\\s*(?!/)\\s*(?P<array2>.*?)\\s*@\\)@|))\\s*(=\\s*(?P<init>.*?)|(@\\(@|)/\\s*(?P<init2>.*?)\\s*/(@\\)@|)|)\\s*\\Z', re.I)\n\n\ndef removespaces(expr):\n    expr = expr.strip()\n    if len(expr) <= 1:\n        return expr\n    expr2 = expr[0]\n    for i in range(1, len(expr) - 1):\n        if (expr[i] == ' ' and\n            ((expr[i + 1] in \"()[]{}=+-/* \") or\n                (expr[i - 1] in \"()[]{}=+-/* \"))):\n            continue\n        expr2 = expr2 + expr[i]\n    expr2 = expr2 + expr[-1]\n    return expr2\n\n\ndef markinnerspaces(line):\n    \"\"\"\n    The function replace all spaces in the input variable line which are \n    surrounded with quotation marks, with the triplet \"@_@\".\n\n    For instance, for the input \"a 'b c'\" the function returns \"a 'b@_@c'\"\n\n    Parameters\n    ----------\n    line : str\n\n    Returns\n    -------\n    str\n\n    \"\"\"  \n    fragment = ''\n    inside = False\n    current_quote = None\n    escaped = ''\n    for c in line:\n        if escaped == '\\\\' and c in ['\\\\', '\\'', '\"']:\n            fragment += c\n            escaped = c\n            continue\n        if not inside and c in ['\\'', '\"']:\n            current_quote = c\n        if c == current_quote:\n            inside = not inside\n        elif c == ' ' and inside:\n            fragment += '@_@'\n            continue\n        fragment += c\n        escaped = c  # reset to non-backslash\n    return fragment\n\n\ndef updatevars(typespec, selector, attrspec, entitydecl):\n    global groupcache, groupcounter\n\n    last_name = None\n    kindselect, charselect, typename = cracktypespec(typespec, selector)\n    if attrspec:\n        attrspec = [x.strip() for x in markoutercomma(attrspec).split('@,@')]\n        l = []\n        c = re.compile(r'(?P<start>[a-zA-Z]+)')\n        for a in attrspec:\n            if not a:\n                continue\n            m = c.match(a)\n            if m:\n                s = m.group('start').lower()\n                a = s + a[len(s):]\n            l.append(a)\n        attrspec = l\n    el = [x.strip() for x in markoutercomma(entitydecl).split('@,@')]\n    el1 = []\n    for e in el:\n        for e1 in [x.strip() for x in markoutercomma(removespaces(markinnerspaces(e)), comma=' ').split('@ @')]:\n            if e1:\n                el1.append(e1.replace('@_@', ' '))\n    for e in el1:\n        m = namepattern.match(e)\n        if not m:\n            outmess(\n                'updatevars: no name pattern found for entity=%s. Skipping.\\n' % (repr(e)))\n            continue\n        ename = rmbadname1(m.group('name'))\n        edecl = {}\n        if ename in groupcache[groupcounter]['vars']:\n            edecl = groupcache[groupcounter]['vars'][ename].copy()\n            not_has_typespec = 'typespec' not in edecl\n            if not_has_typespec:\n                edecl['typespec'] = typespec\n            elif typespec and (not typespec == edecl['typespec']):\n                outmess('updatevars: attempt to change the type of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                    ename, edecl['typespec'], typespec))\n            if 'kindselector' not in edecl:\n                edecl['kindselector'] = copy.copy(kindselect)\n            elif kindselect:\n                for k in list(kindselect.keys()):\n                    if k in edecl['kindselector'] and (not kindselect[k] == edecl['kindselector'][k]):\n                        outmess('updatevars: attempt to change the kindselector \"%s\" of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                            k, ename, edecl['kindselector'][k], kindselect[k]))\n                    else:\n                        edecl['kindselector'][k] = copy.copy(kindselect[k])\n            if 'charselector' not in edecl and charselect:\n                if not_has_typespec:\n                    edecl['charselector'] = charselect\n                else:\n                    errmess('updatevars:%s: attempt to change empty charselector to %r. Ignoring.\\n'\n                            % (ename, charselect))\n            elif charselect:\n                for k in list(charselect.keys()):\n                    if k in edecl['charselector'] and (not charselect[k] == edecl['charselector'][k]):\n                        outmess('updatevars: attempt to change the charselector \"%s\" of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                            k, ename, edecl['charselector'][k], charselect[k]))\n                    else:\n                        edecl['charselector'][k] = copy.copy(charselect[k])\n            if 'typename' not in edecl:\n                edecl['typename'] = typename\n            elif typename and (not edecl['typename'] == typename):\n                outmess('updatevars: attempt to change the typename of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                    ename, edecl['typename'], typename))\n            if 'attrspec' not in edecl:\n                edecl['attrspec'] = copy.copy(attrspec)\n            elif attrspec:\n                for a in attrspec:\n                    if a not in edecl['attrspec']:\n                        edecl['attrspec'].append(a)\n        else:\n            edecl['typespec'] = copy.copy(typespec)\n            edecl['kindselector'] = copy.copy(kindselect)\n            edecl['charselector'] = copy.copy(charselect)\n            edecl['typename'] = typename\n            edecl['attrspec'] = copy.copy(attrspec)\n        if 'external' in (edecl.get('attrspec') or []) and e in groupcache[groupcounter]['args']:\n            if 'externals' not in groupcache[groupcounter]:\n                groupcache[groupcounter]['externals'] = []\n            groupcache[groupcounter]['externals'].append(e)\n        if m.group('after'):\n            m1 = lenarraypattern.match(markouterparen(m.group('after')))\n            if m1:\n                d1 = m1.groupdict()\n                for lk in ['len', 'array', 'init']:\n                    if d1[lk + '2'] is not None:\n                        d1[lk] = d1[lk + '2']\n                        del d1[lk + '2']\n                for k in list(d1.keys()):\n                    if d1[k] is not None:\n                        d1[k] = unmarkouterparen(d1[k])\n                    else:\n                        del d1[k]\n\n                if 'len' in d1:\n                    if typespec in ['complex', 'integer', 'logical', 'real']:\n                        if ('kindselector' not in edecl) or (not edecl['kindselector']):\n                            edecl['kindselector'] = {}\n                        edecl['kindselector']['*'] = d1['len']\n                        del d1['len']\n                    elif typespec == 'character':\n                        if ('charselector' not in edecl) or (not edecl['charselector']):\n                            edecl['charselector'] = {}\n                        if 'len' in edecl['charselector']:\n                            del edecl['charselector']['len']\n                        edecl['charselector']['*'] = d1['len']\n                        del d1['len']\n\n                if 'init' in d1:\n                    if '=' in edecl and (not edecl['='] == d1['init']):\n                        outmess('updatevars: attempt to change the init expression of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                            ename, edecl['='], d1['init']))\n                    else:\n                        edecl['='] = d1['init']\n\n                if 'len' in d1 and 'array' in d1:\n                    if d1['len'] == '':\n                        d1['len'] = d1['array']\n                        del d1['array']\n                    else:\n                        d1['array'] = d1['array'] + ',' + d1['len']\n                        del d1['len']\n                        errmess('updatevars: \"%s %s\" is mapped to \"%s %s(%s)\"\\n' % (\n                            typespec, e, typespec, ename, d1['array']))\n\n                if 'array' in d1:\n                    dm = 'dimension(%s)' % d1['array']\n                    if 'attrspec' not in edecl or (not edecl['attrspec']):\n                        edecl['attrspec'] = [dm]\n                    else:\n                        edecl['attrspec'].append(dm)\n                        for dm1 in edecl['attrspec']:\n                            if dm1[:9] == 'dimension' and dm1 != dm:\n                                del edecl['attrspec'][-1]\n                                errmess('updatevars:%s: attempt to change %r to %r. Ignoring.\\n'\n                                        % (ename, dm1, dm))\n                                break\n\n            else:\n                outmess('updatevars: could not crack entity declaration \"%s\". Ignoring.\\n' % (\n                    ename + m.group('after')))\n        for k in list(edecl.keys()):\n            if not edecl[k]:\n                del edecl[k]\n        groupcache[groupcounter]['vars'][ename] = edecl\n        if 'varnames' in groupcache[groupcounter]:\n            groupcache[groupcounter]['varnames'].append(ename)\n        last_name = ename\n    return last_name\n\n\ndef cracktypespec(typespec, selector):\n    kindselect = None\n    charselect = None\n    typename = None\n    if selector:\n        if typespec in ['complex', 'integer', 'logical', 'real']:\n            kindselect = kindselector.match(selector)\n            if not kindselect:\n                outmess(\n                    'cracktypespec: no kindselector pattern found for %s\\n' % (repr(selector)))\n                return\n            kindselect = kindselect.groupdict()\n            kindselect['*'] = kindselect['kind2']\n            del kindselect['kind2']\n            for k in list(kindselect.keys()):\n                if not kindselect[k]:\n                    del kindselect[k]\n            for k, i in list(kindselect.items()):\n                kindselect[k] = rmbadname1(i)\n        elif typespec == 'character':\n            charselect = charselector.match(selector)\n            if not charselect:\n                outmess(\n                    'cracktypespec: no charselector pattern found for %s\\n' % (repr(selector)))\n                return\n            charselect = charselect.groupdict()\n            charselect['*'] = charselect['charlen']\n            del charselect['charlen']\n            if charselect['lenkind']:\n                lenkind = lenkindpattern.match(\n                    markoutercomma(charselect['lenkind']))\n                lenkind = lenkind.groupdict()\n                for lk in ['len', 'kind']:\n                    if lenkind[lk + '2']:\n                        lenkind[lk] = lenkind[lk + '2']\n                    charselect[lk] = lenkind[lk]\n                    del lenkind[lk + '2']\n                if lenkind['f2py_len'] is not None:\n                    # used to specify the length of assumed length strings\n                    charselect['f2py_len'] = lenkind['f2py_len']\n            del charselect['lenkind']\n            for k in list(charselect.keys()):\n                if not charselect[k]:\n                    del charselect[k]\n            for k, i in list(charselect.items()):\n                charselect[k] = rmbadname1(i)\n        elif typespec == 'type':\n            typename = re.match(r'\\s*\\(\\s*(?P<name>\\w+)\\s*\\)', selector, re.I)\n            if typename:\n                typename = typename.group('name')\n            else:\n                outmess('cracktypespec: no typename found in %s\\n' %\n                        (repr(typespec + selector)))\n        else:\n            outmess('cracktypespec: no selector used for %s\\n' %\n                    (repr(selector)))\n    return kindselect, charselect, typename\n######\n\n\ndef setattrspec(decl, attr, force=0):\n    if not decl:\n        decl = {}\n    if not attr:\n        return decl\n    if 'attrspec' not in decl:\n        decl['attrspec'] = [attr]\n        return decl\n    if force:\n        decl['attrspec'].append(attr)\n    if attr in decl['attrspec']:\n        return decl\n    if attr == 'static' and 'automatic' not in decl['attrspec']:\n        decl['attrspec'].append(attr)\n    elif attr == 'automatic' and 'static' not in decl['attrspec']:\n        decl['attrspec'].append(attr)\n    elif attr == 'public':\n        if 'private' not in decl['attrspec']:\n            decl['attrspec'].append(attr)\n    elif attr == 'private':\n        if 'public' not in decl['attrspec']:\n            decl['attrspec'].append(attr)\n    else:\n        decl['attrspec'].append(attr)\n    return decl\n\n\ndef setkindselector(decl, sel, force=0):\n    if not decl:\n        decl = {}\n    if not sel:\n        return decl\n    if 'kindselector' not in decl:\n        decl['kindselector'] = sel\n        return decl\n    for k in list(sel.keys()):\n        if force or k not in decl['kindselector']:\n            decl['kindselector'][k] = sel[k]\n    return decl\n\n\ndef setcharselector(decl, sel, force=0):\n    if not decl:\n        decl = {}\n    if not sel:\n        return decl\n    if 'charselector' not in decl:\n        decl['charselector'] = sel\n        return decl\n\n    for k in list(sel.keys()):\n        if force or k not in decl['charselector']:\n            decl['charselector'][k] = sel[k]\n    return decl\n\n\ndef getblockname(block, unknown='unknown'):\n    if 'name' in block:\n        return block['name']\n    return unknown\n\n# post processing\n\n\ndef setmesstext(block):\n    global filepositiontext\n\n    try:\n        filepositiontext = 'In: %s:%s\\n' % (block['from'], block['name'])\n    except Exception:\n        pass\n\n\ndef get_usedict(block):\n    usedict = {}\n    if 'parent_block' in block:\n        usedict = get_usedict(block['parent_block'])\n    if 'use' in block:\n        usedict.update(block['use'])\n    return usedict\n\n\ndef get_useparameters(block, param_map=None):\n    global f90modulevars\n\n    if param_map is None:\n        param_map = {}\n    usedict = get_usedict(block)\n    if not usedict:\n        return param_map\n    for usename, mapping in list(usedict.items()):\n        usename = usename.lower()\n        if usename not in f90modulevars:\n            outmess('get_useparameters: no module %s info used by %s\\n' %\n                    (usename, block.get('name')))\n            continue\n        mvars = f90modulevars[usename]\n        params = get_parameters(mvars)\n        if not params:\n            continue\n        # XXX: apply mapping\n        if mapping:\n            errmess('get_useparameters: mapping for %s not impl.\\n' % (mapping))\n        for k, v in list(params.items()):\n            if k in param_map:\n                outmess('get_useparameters: overriding parameter %s with'\n                        ' value from module %s\\n' % (repr(k), repr(usename)))\n            param_map[k] = v\n\n    return param_map\n\n\ndef postcrack2(block, tab='', param_map=None):\n    global f90modulevars\n\n    if not f90modulevars:\n        return block\n    if isinstance(block, list):\n        ret = [postcrack2(g, tab=tab + '\\t', param_map=param_map)\n               for g in block]\n        return ret\n    setmesstext(block)\n    outmess('%sBlock: %s\\n' % (tab, block['name']), 0)\n\n    if param_map is None:\n        param_map = get_useparameters(block)\n\n    if param_map is not None and 'vars' in block:\n        vars = block['vars']\n        for n in list(vars.keys()):\n            var = vars[n]\n            if 'kindselector' in var:\n                kind = var['kindselector']\n                if 'kind' in kind:\n                    val = kind['kind']\n                    if val in param_map:\n                        kind['kind'] = param_map[val]\n    new_body = [postcrack2(b, tab=tab + '\\t', param_map=param_map)\n                for b in block['body']]\n    block['body'] = new_body\n\n    return block\n\n\ndef postcrack(block, args=None, tab=''):\n    \"\"\"\n    TODO:\n          function return values\n          determine expression types if in argument list\n    \"\"\"\n    global usermodules, onlyfunctions\n\n    if isinstance(block, list):\n        gret = []\n        uret = []\n        for g in block:\n            setmesstext(g)\n            g = postcrack(g, tab=tab + '\\t')\n            # sort user routines to appear first\n            if 'name' in g and '__user__' in g['name']:\n                uret.append(g)\n            else:\n                gret.append(g)\n        return uret + gret\n    setmesstext(block)\n    if not isinstance(block, dict) and 'block' not in block:\n        raise Exception('postcrack: Expected block dictionary instead of ' +\n                        str(block))\n    if 'name' in block and not block['name'] == 'unknown_interface':\n        outmess('%sBlock: %s\\n' % (tab, block['name']), 0)\n    block = analyzeargs(block)\n    block = analyzecommon(block)\n    block['vars'] = analyzevars(block)\n    block['sortvars'] = sortvarnames(block['vars'])\n    if 'args' in block and block['args']:\n        args = block['args']\n    block['body'] = analyzebody(block, args, tab=tab)\n\n    userisdefined = []\n    if 'use' in block:\n        useblock = block['use']\n        for k in list(useblock.keys()):\n            if '__user__' in k:\n                userisdefined.append(k)\n    else:\n        useblock = {}\n    name = ''\n    if 'name' in block:\n        name = block['name']\n    # and not userisdefined: # Build a __user__ module\n    if 'externals' in block and block['externals']:\n        interfaced = []\n        if 'interfaced' in block:\n            interfaced = block['interfaced']\n        mvars = copy.copy(block['vars'])\n        if name:\n            mname = name + '__user__routines'\n        else:\n            mname = 'unknown__user__routines'\n        if mname in userisdefined:\n            i = 1\n            while '%s_%i' % (mname, i) in userisdefined:\n                i = i + 1\n            mname = '%s_%i' % (mname, i)\n        interface = {'block': 'interface', 'body': [],\n                     'vars': {}, 'name': name + '_user_interface'}\n        for e in block['externals']:\n            if e in interfaced:\n                edef = []\n                j = -1\n                for b in block['body']:\n                    j = j + 1\n                    if b['block'] == 'interface':\n                        i = -1\n                        for bb in b['body']:\n                            i = i + 1\n                            if 'name' in bb and bb['name'] == e:\n                                edef = copy.copy(bb)\n                                del b['body'][i]\n                                break\n                        if edef:\n                            if not b['body']:\n                                del block['body'][j]\n                            del interfaced[interfaced.index(e)]\n                            break\n                interface['body'].append(edef)\n            else:\n                if e in mvars and not isexternal(mvars[e]):\n                    interface['vars'][e] = mvars[e]\n        if interface['vars'] or interface['body']:\n            block['interfaced'] = interfaced\n            mblock = {'block': 'python module', 'body': [\n                interface], 'vars': {}, 'name': mname, 'interfaced': block['externals']}\n            useblock[mname] = {}\n            usermodules.append(mblock)\n    if useblock:\n        block['use'] = useblock\n    return block\n\n\ndef sortvarnames(vars):\n    indep = []\n    dep = []\n    for v in list(vars.keys()):\n        if 'depend' in vars[v] and vars[v]['depend']:\n            dep.append(v)\n        else:\n            indep.append(v)\n    n = len(dep)\n    i = 0\n    while dep:  # XXX: How to catch dependence cycles correctly?\n        v = dep[0]\n        fl = 0\n        for w in dep[1:]:\n            if w in vars[v]['depend']:\n                fl = 1\n                break\n        if fl:\n            dep = dep[1:] + [v]\n            i = i + 1\n            if i > n:\n                errmess('sortvarnames: failed to compute dependencies because'\n                        ' of cyclic dependencies between '\n                        + ', '.join(dep) + '\\n')\n                indep = indep + dep\n                break\n        else:\n            indep.append(v)\n            dep = dep[1:]\n            n = len(dep)\n            i = 0\n    return indep\n\n\ndef analyzecommon(block):\n    if not hascommon(block):\n        return block\n    commonvars = []\n    for k in list(block['common'].keys()):\n        comvars = []\n        for e in block['common'][k]:\n            m = re.match(\n                r'\\A\\s*\\b(?P<name>.*?)\\b\\s*(\\((?P<dims>.*?)\\)|)\\s*\\Z', e, re.I)\n            if m:\n                dims = []\n                if m.group('dims'):\n                    dims = [x.strip()\n                            for x in markoutercomma(m.group('dims')).split('@,@')]\n                n = rmbadname1(m.group('name').strip())\n                if n in block['vars']:\n                    if 'attrspec' in block['vars'][n]:\n                        block['vars'][n]['attrspec'].append(\n                            'dimension(%s)' % (','.join(dims)))\n                    else:\n                        block['vars'][n]['attrspec'] = [\n                            'dimension(%s)' % (','.join(dims))]\n                else:\n                    if dims:\n                        block['vars'][n] = {\n                            'attrspec': ['dimension(%s)' % (','.join(dims))]}\n                    else:\n                        block['vars'][n] = {}\n                if n not in commonvars:\n                    commonvars.append(n)\n            else:\n                n = e\n                errmess(\n                    'analyzecommon: failed to extract \"<name>[(<dims>)]\" from \"%s\" in common /%s/.\\n' % (e, k))\n            comvars.append(n)\n        block['common'][k] = comvars\n    if 'commonvars' not in block:\n        block['commonvars'] = commonvars\n    else:\n        block['commonvars'] = block['commonvars'] + commonvars\n    return block\n\n\ndef analyzebody(block, args, tab=''):\n    global usermodules, skipfuncs, onlyfuncs, f90modulevars\n\n    setmesstext(block)\n    body = []\n    for b in block['body']:\n        b['parent_block'] = block\n        if b['block'] in ['function', 'subroutine']:\n            if args is not None and b['name'] not in args:\n                continue\n            else:\n                as_ = b['args']\n            if b['name'] in skipfuncs:\n                continue\n            if onlyfuncs and b['name'] not in onlyfuncs:\n                continue\n            b['saved_interface'] = crack2fortrangen(\n                b, '\\n' + ' ' * 6, as_interface=True)\n\n        else:\n            as_ = args\n        b = postcrack(b, as_, tab=tab + '\\t')\n        if b['block'] in ['interface', 'abstract interface'] and \\\n           not b['body'] and not b.get('implementedby'):\n            if 'f2pyenhancements' not in b:\n                continue\n        if b['block'].replace(' ', '') == 'pythonmodule':\n            usermodules.append(b)\n        else:\n            if b['block'] == 'module':\n                f90modulevars[b['name']] = b['vars']\n            body.append(b)\n    return body\n\n\ndef buildimplicitrules(block):\n    setmesstext(block)\n    implicitrules = defaultimplicitrules\n    attrrules = {}\n    if 'implicit' in block:\n        if block['implicit'] is None:\n            implicitrules = None\n            if verbose > 1:\n                outmess(\n                    'buildimplicitrules: no implicit rules for routine %s.\\n' % repr(block['name']))\n        else:\n            for k in list(block['implicit'].keys()):\n                if block['implicit'][k].get('typespec') not in ['static', 'automatic']:\n                    implicitrules[k] = block['implicit'][k]\n                else:\n                    attrrules[k] = block['implicit'][k]['typespec']\n    return implicitrules, attrrules\n\n\ndef myeval(e, g=None, l=None):\n    \"\"\" Like `eval` but returns only integers and floats \"\"\"\n    r = eval(e, g, l)\n    if type(r) in [int, float]:\n        return r\n    raise ValueError('r=%r' % (r))\n\ngetlincoef_re_1 = re.compile(r'\\A\\b\\w+\\b\\Z', re.I)\n\n\ndef getlincoef(e, xset):  # e = a*x+b ; x in xset\n    \"\"\"\n    Obtain ``a`` and ``b`` when ``e == \"a*x+b\"``, where ``x`` is a symbol in\n    xset.\n\n    >>> getlincoef('2*x + 1', {'x'})\n    (2, 1, 'x')\n    >>> getlincoef('3*x + x*2 + 2 + 1', {'x'})\n    (5, 3, 'x')\n    >>> getlincoef('0', {'x'})\n    (0, 0, None)\n    >>> getlincoef('0*x', {'x'})\n    (0, 0, 'x')\n    >>> getlincoef('x*x', {'x'})\n    (None, None, None)\n\n    This can be tricked by sufficiently complex expressions\n\n    >>> getlincoef('(x - 0.5)*(x - 1.5)*(x - 1)*x + 2*x + 3', {'x'})\n    (2.0, 3.0, 'x')\n    \"\"\"\n    try:\n        c = int(myeval(e, {}, {}))\n        return 0, c, None\n    except Exception:\n        pass\n    if getlincoef_re_1.match(e):\n        return 1, 0, e\n    len_e = len(e)\n    for x in xset:\n        if len(x) > len_e:\n            continue\n        if re.search(r'\\w\\s*\\([^)]*\\b' + x + r'\\b', e):\n            # skip function calls having x as an argument, e.g max(1, x)\n            continue\n        re_1 = re.compile(r'(?P<before>.*?)\\b' + x + r'\\b(?P<after>.*)', re.I)\n        m = re_1.match(e)\n        if m:\n            try:\n                m1 = re_1.match(e)\n                while m1:\n                    ee = '%s(%s)%s' % (\n                        m1.group('before'), 0, m1.group('after'))\n                    m1 = re_1.match(ee)\n                b = myeval(ee, {}, {})\n                m1 = re_1.match(e)\n                while m1:\n                    ee = '%s(%s)%s' % (\n                        m1.group('before'), 1, m1.group('after'))\n                    m1 = re_1.match(ee)\n                a = myeval(ee, {}, {}) - b\n                m1 = re_1.match(e)\n                while m1:\n                    ee = '%s(%s)%s' % (\n                        m1.group('before'), 0.5, m1.group('after'))\n                    m1 = re_1.match(ee)\n                c = myeval(ee, {}, {})\n                # computing another point to be sure that expression is linear\n                m1 = re_1.match(e)\n                while m1:\n                    ee = '%s(%s)%s' % (\n                        m1.group('before'), 1.5, m1.group('after'))\n                    m1 = re_1.match(ee)\n                c2 = myeval(ee, {}, {})\n                if (a * 0.5 + b == c and a * 1.5 + b == c2):\n                    return a, b, x\n            except Exception:\n                pass\n            break\n    return None, None, None\n\n\nword_pattern = re.compile(r'\\b[a-z][\\w$]*\\b', re.I)\n\n\ndef _get_depend_dict(name, vars, deps):\n    if name in vars:\n        words = vars[name].get('depend', [])\n\n        if '=' in vars[name] and not isstring(vars[name]):\n            for word in word_pattern.findall(vars[name]['=']):\n                # The word_pattern may return values that are not\n                # only variables, they can be string content for instance\n                if word not in words and word in vars and word != name:\n                    words.append(word)\n        for word in words[:]:\n            for w in deps.get(word, []) \\\n                    or _get_depend_dict(word, vars, deps):\n                if w not in words:\n                    words.append(w)\n    else:\n        outmess('_get_depend_dict: no dependence info for %s\\n' % (repr(name)))\n        words = []\n    deps[name] = words\n    return words\n\n\ndef _calc_depend_dict(vars):\n    names = list(vars.keys())\n    depend_dict = {}\n    for n in names:\n        _get_depend_dict(n, vars, depend_dict)\n    return depend_dict\n\n\ndef get_sorted_names(vars):\n    \"\"\"\n    \"\"\"\n    depend_dict = _calc_depend_dict(vars)\n    names = []\n    for name in list(depend_dict.keys()):\n        if not depend_dict[name]:\n            names.append(name)\n            del depend_dict[name]\n    while depend_dict:\n        for name, lst in list(depend_dict.items()):\n            new_lst = [n for n in lst if n in depend_dict]\n            if not new_lst:\n                names.append(name)\n                del depend_dict[name]\n            else:\n                depend_dict[name] = new_lst\n    return [name for name in names if name in vars]\n\n\ndef _kind_func(string):\n    # XXX: return something sensible.\n    if string[0] in \"'\\\"\":\n        string = string[1:-1]\n    if real16pattern.match(string):\n        return 8\n    elif real8pattern.match(string):\n        return 4\n    return 'kind(' + string + ')'\n\n\ndef _selected_int_kind_func(r):\n    # XXX: This should be processor dependent\n    m = 10 ** r\n    if m <= 2 ** 8:\n        return 1\n    if m <= 2 ** 16:\n        return 2\n    if m <= 2 ** 32:\n        return 4\n    if m <= 2 ** 63:\n        return 8\n    if m <= 2 ** 128:\n        return 16\n    return -1\n\n\ndef _selected_real_kind_func(p, r=0, radix=0):\n    # XXX: This should be processor dependent\n    # This is only verified for 0 <= p <= 20, possibly good for p <= 33 and above\n    if p < 7:\n        return 4\n    if p < 16:\n        return 8\n    machine = platform.machine().lower()\n    if machine.startswith(('aarch64', 'arm64', 'power', 'ppc', 'riscv', 's390x', 'sparc')):\n        if p <= 33:\n            return 16\n    else:\n        if p < 19:\n            return 10\n        elif p <= 33:\n            return 16\n    return -1\n\n\ndef get_parameters(vars, global_params={}):\n    params = copy.copy(global_params)\n    g_params = copy.copy(global_params)\n    for name, func in [('kind', _kind_func),\n                       ('selected_int_kind', _selected_int_kind_func),\n                       ('selected_real_kind', _selected_real_kind_func), ]:\n        if name not in g_params:\n            g_params[name] = func\n    param_names = []\n    for n in get_sorted_names(vars):\n        if 'attrspec' in vars[n] and 'parameter' in vars[n]['attrspec']:\n            param_names.append(n)\n    kind_re = re.compile(r'\\bkind\\s*\\(\\s*(?P<value>.*)\\s*\\)', re.I)\n    selected_int_kind_re = re.compile(\n        r'\\bselected_int_kind\\s*\\(\\s*(?P<value>.*)\\s*\\)', re.I)\n    selected_kind_re = re.compile(\n        r'\\bselected_(int|real)_kind\\s*\\(\\s*(?P<value>.*)\\s*\\)', re.I)\n    for n in param_names:\n        if '=' in vars[n]:\n            v = vars[n]['=']\n            if islogical(vars[n]):\n                v = v.lower()\n                for repl in [\n                    ('.false.', 'False'),\n                    ('.true.', 'True'),\n                    # TODO: test .eq., .neq., etc replacements.\n                ]:\n                    v = v.replace(*repl)\n            v = kind_re.sub(r'kind(\"\\1\")', v)\n            v = selected_int_kind_re.sub(r'selected_int_kind(\\1)', v)\n\n            # We need to act according to the data.\n            # The easy case is if the data has a kind-specifier,\n            # then we may easily remove those specifiers.\n            # However, it may be that the user uses other specifiers...(!)\n            is_replaced = False\n            if 'kindselector' in vars[n]:\n                if 'kind' in vars[n]['kindselector']:\n                    orig_v_len = len(v)\n                    v = v.replace('_' + vars[n]['kindselector']['kind'], '')\n                    # Again, this will be true if even a single specifier\n                    # has been replaced, see comment above.\n                    is_replaced = len(v) < orig_v_len\n                    \n            if not is_replaced:\n                if not selected_kind_re.match(v):\n                    v_ = v.split('_')\n                    # In case there are additive parameters\n                    if len(v_) > 1: \n                        v = ''.join(v_[:-1]).lower().replace(v_[-1].lower(), '')\n\n            # Currently this will not work for complex numbers.\n            # There is missing code for extracting a complex number,\n            # which may be defined in either of these:\n            #  a) (Re, Im)\n            #  b) cmplx(Re, Im)\n            #  c) dcmplx(Re, Im)\n            #  d) cmplx(Re, Im, <prec>)\n\n            if isdouble(vars[n]):\n                tt = list(v)\n                for m in real16pattern.finditer(v):\n                    tt[m.start():m.end()] = list(\n                        v[m.start():m.end()].lower().replace('d', 'e'))\n                v = ''.join(tt)\n\n            elif iscomplex(vars[n]):\n                outmess(f'get_parameters[TODO]: '\n                        f'implement evaluation of complex expression {v}\\n')\n\n            # Handle _dp for gh-6624\n            # Also fixes gh-20460\n            if real16pattern.search(v):\n                v = 8\n            elif real8pattern.search(v):\n                v = 4\n            try:\n                params[n] = eval(v, g_params, params)\n\n            except Exception as msg:\n                params[n] = v\n                outmess('get_parameters: got \"%s\" on %s\\n' % (msg, repr(v)))\n            if isstring(vars[n]) and isinstance(params[n], int):\n                params[n] = chr(params[n])\n            nl = n.lower()\n            if nl != n:\n                params[nl] = params[n]\n        else:\n            print(vars[n])\n            outmess(\n                'get_parameters:parameter %s does not have value?!\\n' % (repr(n)))\n    return params\n\n\ndef _eval_length(length, params):\n    if length in ['(:)', '(*)', '*']:\n        return '(*)'\n    return _eval_scalar(length, params)\n\n_is_kind_number = re.compile(r'\\d+_').match\n\n\ndef _eval_scalar(value, params):\n    if _is_kind_number(value):\n        value = value.split('_')[0]\n    try:\n        # TODO: use symbolic from PR #19805\n        value = eval(value, {}, params)\n        value = (repr if isinstance(value, str) else str)(value)\n    except (NameError, SyntaxError, TypeError):\n        return value\n    except Exception as msg:\n        errmess('\"%s\" in evaluating %r '\n                '(available names: %s)\\n'\n                % (msg, value, list(params.keys())))\n    return value\n\n\ndef analyzevars(block):\n    global f90modulevars\n\n    setmesstext(block)\n    implicitrules, attrrules = buildimplicitrules(block)\n    vars = copy.copy(block['vars'])\n    if block['block'] == 'function' and block['name'] not in vars:\n        vars[block['name']] = {}\n    if '' in block['vars']:\n        del vars['']\n        if 'attrspec' in block['vars']['']:\n            gen = block['vars']['']['attrspec']\n            for n in set(vars) | set(b['name'] for b in block['body']):\n                for k in ['public', 'private']:\n                    if k in gen:\n                        vars[n] = setattrspec(vars.get(n, {}), k)\n    svars = []\n    args = block['args']\n    for a in args:\n        try:\n            vars[a]\n            svars.append(a)\n        except KeyError:\n            pass\n    for n in list(vars.keys()):\n        if n not in args:\n            svars.append(n)\n\n    params = get_parameters(vars, get_useparameters(block))\n\n    dep_matches = {}\n    name_match = re.compile(r'[A-Za-z][\\w$]*').match\n    for v in list(vars.keys()):\n        m = name_match(v)\n        if m:\n            n = v[m.start():m.end()]\n            try:\n                dep_matches[n]\n            except KeyError:\n                dep_matches[n] = re.compile(r'.*\\b%s\\b' % (v), re.I).match\n    for n in svars:\n        if n[0] in list(attrrules.keys()):\n            vars[n] = setattrspec(vars[n], attrrules[n[0]])\n        if 'typespec' not in vars[n]:\n            if not('attrspec' in vars[n] and 'external' in vars[n]['attrspec']):\n                if implicitrules:\n                    ln0 = n[0].lower()\n                    for k in list(implicitrules[ln0].keys()):\n                        if k == 'typespec' and implicitrules[ln0][k] == 'undefined':\n                            continue\n                        if k not in vars[n]:\n                            vars[n][k] = implicitrules[ln0][k]\n                        elif k == 'attrspec':\n                            for l in implicitrules[ln0][k]:\n                                vars[n] = setattrspec(vars[n], l)\n                elif n in block['args']:\n                    outmess('analyzevars: typespec of variable %s is not defined in routine %s.\\n' % (\n                        repr(n), block['name']))\n        if 'charselector' in vars[n]:\n            if 'len' in vars[n]['charselector']:\n                l = vars[n]['charselector']['len']\n                try:\n                    l = str(eval(l, {}, params))\n                except Exception:\n                    pass\n                vars[n]['charselector']['len'] = l\n\n        if 'kindselector' in vars[n]:\n            if 'kind' in vars[n]['kindselector']:\n                l = vars[n]['kindselector']['kind']\n                try:\n                    l = str(eval(l, {}, params))\n                except Exception:\n                    pass\n                vars[n]['kindselector']['kind'] = l\n\n        dimension_exprs = {}\n        if 'attrspec' in vars[n]:\n            attr = vars[n]['attrspec']\n            attr.reverse()\n            vars[n]['attrspec'] = []\n            dim, intent, depend, check, note = None, None, None, None, None\n            for a in attr:\n                if a[:9] == 'dimension':\n                    dim = (a[9:].strip())[1:-1]\n                elif a[:6] == 'intent':\n                    intent = (a[6:].strip())[1:-1]\n                elif a[:6] == 'depend':\n                    depend = (a[6:].strip())[1:-1]\n                elif a[:5] == 'check':\n                    check = (a[5:].strip())[1:-1]\n                elif a[:4] == 'note':\n                    note = (a[4:].strip())[1:-1]\n                else:\n                    vars[n] = setattrspec(vars[n], a)\n                if intent:\n                    if 'intent' not in vars[n]:\n                        vars[n]['intent'] = []\n                    for c in [x.strip() for x in markoutercomma(intent).split('@,@')]:\n                        # Remove spaces so that 'in out' becomes 'inout'\n                        tmp = c.replace(' ', '')\n                        if tmp not in vars[n]['intent']:\n                            vars[n]['intent'].append(tmp)\n                    intent = None\n                if note:\n                    note = note.replace('\\\\n\\\\n', '\\n\\n')\n                    note = note.replace('\\\\n ', '\\n')\n                    if 'note' not in vars[n]:\n                        vars[n]['note'] = [note]\n                    else:\n                        vars[n]['note'].append(note)\n                    note = None\n                if depend is not None:\n                    if 'depend' not in vars[n]:\n                        vars[n]['depend'] = []\n                    for c in rmbadname([x.strip() for x in markoutercomma(depend).split('@,@')]):\n                        if c not in vars[n]['depend']:\n                            vars[n]['depend'].append(c)\n                    depend = None\n                if check is not None:\n                    if 'check' not in vars[n]:\n                        vars[n]['check'] = []\n                    for c in [x.strip() for x in markoutercomma(check).split('@,@')]:\n                        if c not in vars[n]['check']:\n                            vars[n]['check'].append(c)\n                    check = None\n            if dim and 'dimension' not in vars[n]:\n                vars[n]['dimension'] = []\n                for d in rmbadname([x.strip() for x in markoutercomma(dim).split('@,@')]):\n                    star = ':' if d == ':' else '*'\n                    # Evaluate `d` with respect to params\n                    if d in params:\n                        d = str(params[d])\n                    for p in params:\n                        re_1 = re.compile(r'(?P<before>.*?)\\b' + p + r'\\b(?P<after>.*)', re.I)\n                        m = re_1.match(d)\n                        while m:\n                            d = m.group('before') + \\\n                                str(params[p]) + m.group('after')\n                            m = re_1.match(d)\n\n                    if d == star:\n                        dl = [star]\n                    else:\n                        dl = markoutercomma(d, ':').split('@:@')\n                    if len(dl) == 2 and '*' in dl:  # e.g. dimension(5:*)\n                        dl = ['*']\n                        d = '*'\n                    if len(dl) == 1 and dl[0] != star:\n                        dl = ['1', dl[0]]\n                    if len(dl) == 2:\n                        d1, d2 = map(symbolic.Expr.parse, dl)\n                        dsize = d2 - d1 + 1\n                        d = dsize.tostring(language=symbolic.Language.C)\n                        # find variables v that define d as a linear\n                        # function, `d == a * v + b`, and store\n                        # coefficients a and b for further analysis.\n                        solver_and_deps = {}\n                        for v in block['vars']:\n                            s = symbolic.as_symbol(v)\n                            if dsize.contains(s):\n                                try:\n                                    a, b = dsize.linear_solve(s)\n\n                                    def solve_v(s, a=a, b=b):\n                                        return (s - b) / a\n\n                                    all_symbols = set(a.symbols())\n                                    all_symbols.update(b.symbols())\n                                except RuntimeError as msg:\n                                    # d is not a linear function of v,\n                                    # however, if v can be determined\n                                    # from d using other means,\n                                    # implement the corresponding\n                                    # solve_v function here.\n                                    solve_v = None\n                                    all_symbols = set(dsize.symbols())\n                                v_deps = set(\n                                    s.data for s in all_symbols\n                                    if s.data in vars)\n                                solver_and_deps[v] = solve_v, list(v_deps)\n                        # Note that dsize may contain symbols that are\n                        # not defined in block['vars']. Here we assume\n                        # these correspond to Fortran/C intrinsic\n                        # functions or that are defined by other\n                        # means. We'll let the compiler validate the\n                        # definiteness of such symbols.\n                        dimension_exprs[d] = solver_and_deps\n                    vars[n]['dimension'].append(d)\n\n        if 'check' not in vars[n] and 'args' in block and n in block['args']:\n            # n is an argument that has no checks defined. Here we\n            # generate some consistency checks for n, and when n is an\n            # array, generate checks for its dimensions and construct\n            # initialization expressions.\n            n_deps = vars[n].get('depend', [])\n            n_checks = []\n            n_is_input = l_or(isintent_in, isintent_inout,\n                              isintent_inplace)(vars[n])\n            if isarray(vars[n]):  # n is array\n                for i, d in enumerate(vars[n]['dimension']):\n                    coeffs_and_deps = dimension_exprs.get(d)\n                    if coeffs_and_deps is None:\n                        # d is `:` or `*` or a constant expression\n                        pass\n                    elif n_is_input:\n                        # n is an input array argument and its shape\n                        # may define variables used in dimension\n                        # specifications.\n                        for v, (solver, deps) in coeffs_and_deps.items():\n                            def compute_deps(v, deps):\n                                for v1 in coeffs_and_deps.get(v, [None, []])[1]:\n                                    if v1 not in deps:\n                                        deps.add(v1)\n                                        compute_deps(v1, deps)\n                            all_deps = set()\n                            compute_deps(v, all_deps)\n                            if ((v in n_deps\n                                 or '=' in vars[v]\n                                 or 'depend' in vars[v])):\n                                # Skip a variable that\n                                # - n depends on\n                                # - has user-defined initialization expression\n                                # - has user-defined dependencies\n                                continue\n                            if solver is not None and v not in all_deps:\n                                # v can be solved from d, hence, we\n                                # make it an optional argument with\n                                # initialization expression:\n                                is_required = False\n                                init = solver(symbolic.as_symbol(\n                                    f'shape({n}, {i})'))\n                                init = init.tostring(\n                                    language=symbolic.Language.C)\n                                vars[v]['='] = init\n                                # n needs to be initialized before v. So,\n                                # making v dependent on n and on any\n                                # variables in solver or d.\n                                vars[v]['depend'] = [n] + deps\n                                if 'check' not in vars[v]:\n                                    # add check only when no\n                                    # user-specified checks exist\n                                    vars[v]['check'] = [\n                                        f'shape({n}, {i}) == {d}']\n                            else:\n                                # d is a non-linear function on v,\n                                # hence, v must be a required input\n                                # argument that n will depend on\n                                is_required = True\n                                if 'intent' not in vars[v]:\n                                    vars[v]['intent'] = []\n                                if 'in' not in vars[v]['intent']:\n                                    vars[v]['intent'].append('in')\n                                # v needs to be initialized before n\n                                n_deps.append(v)\n                                n_checks.append(\n                                    f'shape({n}, {i}) == {d}')\n                            v_attr = vars[v].get('attrspec', [])\n                            if not ('optional' in v_attr\n                                    or 'required' in v_attr):\n                                v_attr.append(\n                                    'required' if is_required else 'optional')\n                            if v_attr:\n                                vars[v]['attrspec'] = v_attr\n                    if coeffs_and_deps is not None:\n                        # extend v dependencies with ones specified in attrspec\n                        for v, (solver, deps) in coeffs_and_deps.items():\n                            v_deps = vars[v].get('depend', [])\n                            for aa in vars[v].get('attrspec', []):\n                                if aa.startswith('depend'):\n                                    aa = ''.join(aa.split())\n                                    v_deps.extend(aa[7:-1].split(','))\n                            if v_deps:\n                                vars[v]['depend'] = list(set(v_deps))\n                            if n not in v_deps:\n                                n_deps.append(v)\n            elif isstring(vars[n]):\n                if 'charselector' in vars[n]:\n                    if '*' in vars[n]['charselector']:\n                        length = _eval_length(vars[n]['charselector']['*'],\n                                              params)\n                        vars[n]['charselector']['*'] = length\n                    elif 'len' in vars[n]['charselector']:\n                        length = _eval_length(vars[n]['charselector']['len'],\n                                              params)\n                        del vars[n]['charselector']['len']\n                        vars[n]['charselector']['*'] = length\n            if n_checks:\n                vars[n]['check'] = n_checks\n            if n_deps:\n                vars[n]['depend'] = list(set(n_deps))\n\n        if '=' in vars[n]:\n            if 'attrspec' not in vars[n]:\n                vars[n]['attrspec'] = []\n            if ('optional' not in vars[n]['attrspec']) and \\\n               ('required' not in vars[n]['attrspec']):\n                vars[n]['attrspec'].append('optional')\n            if 'depend' not in vars[n]:\n                vars[n]['depend'] = []\n                for v, m in list(dep_matches.items()):\n                    if m(vars[n]['=']):\n                        vars[n]['depend'].append(v)\n                if not vars[n]['depend']:\n                    del vars[n]['depend']\n            if isscalar(vars[n]):\n                vars[n]['='] = _eval_scalar(vars[n]['='], params)\n\n    for n in list(vars.keys()):\n        if n == block['name']:  # n is block name\n            if 'note' in vars[n]:\n                block['note'] = vars[n]['note']\n            if block['block'] == 'function':\n                if 'result' in block and block['result'] in vars:\n                    vars[n] = appenddecl(vars[n], vars[block['result']])\n                if 'prefix' in block:\n                    pr = block['prefix']\n                    pr1 = pr.replace('pure', '')\n                    ispure = (not pr == pr1)\n                    pr = pr1.replace('recursive', '')\n                    isrec = (not pr == pr1)\n                    m = typespattern[0].match(pr)\n                    if m:\n                        typespec, selector, attr, edecl = cracktypespec0(\n                            m.group('this'), m.group('after'))\n                        kindselect, charselect, typename = cracktypespec(\n                            typespec, selector)\n                        vars[n]['typespec'] = typespec\n                        try:\n                            if block['result']:\n                                vars[block['result']]['typespec'] = typespec\n                        except Exception:\n                            pass\n                        if kindselect:\n                            if 'kind' in kindselect:\n                                try:\n                                    kindselect['kind'] = eval(\n                                        kindselect['kind'], {}, params)\n                                except Exception:\n                                    pass\n                            vars[n]['kindselector'] = kindselect\n                        if charselect:\n                            vars[n]['charselector'] = charselect\n                        if typename:\n                            vars[n]['typename'] = typename\n                        if ispure:\n                            vars[n] = setattrspec(vars[n], 'pure')\n                        if isrec:\n                            vars[n] = setattrspec(vars[n], 'recursive')\n                    else:\n                        outmess(\n                            'analyzevars: prefix (%s) were not used\\n' % repr(block['prefix']))\n    if not block['block'] in ['module', 'pythonmodule', 'python module', 'block data']:\n        if 'commonvars' in block:\n            neededvars = copy.copy(block['args'] + block['commonvars'])\n        else:\n            neededvars = copy.copy(block['args'])\n        for n in list(vars.keys()):\n            if l_or(isintent_callback, isintent_aux)(vars[n]):\n                neededvars.append(n)\n        if 'entry' in block:\n            neededvars.extend(list(block['entry'].keys()))\n            for k in list(block['entry'].keys()):\n                for n in block['entry'][k]:\n                    if n not in neededvars:\n                        neededvars.append(n)\n        if block['block'] == 'function':\n            if 'result' in block:\n                neededvars.append(block['result'])\n            else:\n                neededvars.append(block['name'])\n        if block['block'] in ['subroutine', 'function']:\n            name = block['name']\n            if name in vars and 'intent' in vars[name]:\n                block['intent'] = vars[name]['intent']\n        if block['block'] == 'type':\n            neededvars.extend(list(vars.keys()))\n        for n in list(vars.keys()):\n            if n not in neededvars:\n                del vars[n]\n    return vars\n\nanalyzeargs_re_1 = re.compile(r'\\A[a-z]+[\\w$]*\\Z', re.I)\n\n\ndef expr2name(a, block, args=[]):\n    orig_a = a\n    a_is_expr = not analyzeargs_re_1.match(a)\n    if a_is_expr:  # `a` is an expression\n        implicitrules, attrrules = buildimplicitrules(block)\n        at = determineexprtype(a, block['vars'], implicitrules)\n        na = 'e_'\n        for c in a:\n            c = c.lower()\n            if c not in string.ascii_lowercase + string.digits:\n                c = '_'\n            na = na + c\n        if na[-1] == '_':\n            na = na + 'e'\n        else:\n            na = na + '_e'\n        a = na\n        while a in block['vars'] or a in block['args']:\n            a = a + 'r'\n    if a in args:\n        k = 1\n        while a + str(k) in args:\n            k = k + 1\n        a = a + str(k)\n    if a_is_expr:\n        block['vars'][a] = at\n    else:\n        if a not in block['vars']:\n            if orig_a in block['vars']:\n                block['vars'][a] = block['vars'][orig_a]\n            else:\n                block['vars'][a] = {}\n        if 'externals' in block and orig_a in block['externals'] + block['interfaced']:\n            block['vars'][a] = setattrspec(block['vars'][a], 'external')\n    return a\n\n\ndef analyzeargs(block):\n    setmesstext(block)\n    implicitrules, _ = buildimplicitrules(block)\n    if 'args' not in block:\n        block['args'] = []\n    args = []\n    for a in block['args']:\n        a = expr2name(a, block, args)\n        args.append(a)\n    block['args'] = args\n    if 'entry' in block:\n        for k, args1 in list(block['entry'].items()):\n            for a in args1:\n                if a not in block['vars']:\n                    block['vars'][a] = {}\n\n    for b in block['body']:\n        if b['name'] in args:\n            if 'externals' not in block:\n                block['externals'] = []\n            if b['name'] not in block['externals']:\n                block['externals'].append(b['name'])\n    if 'result' in block and block['result'] not in block['vars']:\n        block['vars'][block['result']] = {}\n    return block\n\ndetermineexprtype_re_1 = re.compile(r'\\A\\(.+?,.+?\\)\\Z', re.I)\ndetermineexprtype_re_2 = re.compile(r'\\A[+-]?\\d+(_(?P<name>\\w+)|)\\Z', re.I)\ndetermineexprtype_re_3 = re.compile(\n    r'\\A[+-]?[\\d.]+[-\\d+de.]*(_(?P<name>\\w+)|)\\Z', re.I)\ndetermineexprtype_re_4 = re.compile(r'\\A\\(.*\\)\\Z', re.I)\ndetermineexprtype_re_5 = re.compile(r'\\A(?P<name>\\w+)\\s*\\(.*?\\)\\s*\\Z', re.I)\n\n\ndef _ensure_exprdict(r):\n    if isinstance(r, int):\n        return {'typespec': 'integer'}\n    if isinstance(r, float):\n        return {'typespec': 'real'}\n    if isinstance(r, complex):\n        return {'typespec': 'complex'}\n    if isinstance(r, dict):\n        return r\n    raise AssertionError(repr(r))\n\n\ndef determineexprtype(expr, vars, rules={}):\n    if expr in vars:\n        return _ensure_exprdict(vars[expr])\n    expr = expr.strip()\n    if determineexprtype_re_1.match(expr):\n        return {'typespec': 'complex'}\n    m = determineexprtype_re_2.match(expr)\n    if m:\n        if 'name' in m.groupdict() and m.group('name'):\n            outmess(\n                'determineexprtype: selected kind types not supported (%s)\\n' % repr(expr))\n        return {'typespec': 'integer'}\n    m = determineexprtype_re_3.match(expr)\n    if m:\n        if 'name' in m.groupdict() and m.group('name'):\n            outmess(\n                'determineexprtype: selected kind types not supported (%s)\\n' % repr(expr))\n        return {'typespec': 'real'}\n    for op in ['+', '-', '*', '/']:\n        for e in [x.strip() for x in markoutercomma(expr, comma=op).split('@' + op + '@')]:\n            if e in vars:\n                return _ensure_exprdict(vars[e])\n    t = {}\n    if determineexprtype_re_4.match(expr):  # in parenthesis\n        t = determineexprtype(expr[1:-1], vars, rules)\n    else:\n        m = determineexprtype_re_5.match(expr)\n        if m:\n            rn = m.group('name')\n            t = determineexprtype(m.group('name'), vars, rules)\n            if t and 'attrspec' in t:\n                del t['attrspec']\n            if not t:\n                if rn[0] in rules:\n                    return _ensure_exprdict(rules[rn[0]])\n    if expr[0] in '\\'\"':\n        return {'typespec': 'character', 'charselector': {'*': '*'}}\n    if not t:\n        outmess(\n            'determineexprtype: could not determine expressions (%s) type.\\n' % (repr(expr)))\n    return t\n\n######\n\n\ndef crack2fortrangen(block, tab='\\n', as_interface=False):\n    global skipfuncs, onlyfuncs\n\n    setmesstext(block)\n    ret = ''\n    if isinstance(block, list):\n        for g in block:\n            if g and g['block'] in ['function', 'subroutine']:\n                if g['name'] in skipfuncs:\n                    continue\n                if onlyfuncs and g['name'] not in onlyfuncs:\n                    continue\n            ret = ret + crack2fortrangen(g, tab, as_interface=as_interface)\n        return ret\n    prefix = ''\n    name = ''\n    args = ''\n    blocktype = block['block']\n    if blocktype == 'program':\n        return ''\n    argsl = []\n    if 'name' in block:\n        name = block['name']\n    if 'args' in block:\n        vars = block['vars']\n        for a in block['args']:\n            a = expr2name(a, block, argsl)\n            if not isintent_callback(vars[a]):\n                argsl.append(a)\n        if block['block'] == 'function' or argsl:\n            args = '(%s)' % ','.join(argsl)\n    f2pyenhancements = ''\n    if 'f2pyenhancements' in block:\n        for k in list(block['f2pyenhancements'].keys()):\n            f2pyenhancements = '%s%s%s %s' % (\n                f2pyenhancements, tab + tabchar, k, block['f2pyenhancements'][k])\n    intent_lst = block.get('intent', [])[:]\n    if blocktype == 'function' and 'callback' in intent_lst:\n        intent_lst.remove('callback')\n    if intent_lst:\n        f2pyenhancements = '%s%sintent(%s) %s' %\\\n                           (f2pyenhancements, tab + tabchar,\n                            ','.join(intent_lst), name)\n    use = ''\n    if 'use' in block:\n        use = use2fortran(block['use'], tab + tabchar)\n    common = ''\n    if 'common' in block:\n        common = common2fortran(block['common'], tab + tabchar)\n    if name == 'unknown_interface':\n        name = ''\n    result = ''\n    if 'result' in block:\n        result = ' result (%s)' % block['result']\n        if block['result'] not in argsl:\n            argsl.append(block['result'])\n    body = crack2fortrangen(block['body'], tab + tabchar, as_interface=as_interface)\n    vars = vars2fortran(\n        block, block['vars'], argsl, tab + tabchar, as_interface=as_interface)\n    mess = ''\n    if 'from' in block and not as_interface:\n        mess = '! in %s' % block['from']\n    if 'entry' in block:\n        entry_stmts = ''\n        for k, i in list(block['entry'].items()):\n            entry_stmts = '%s%sentry %s(%s)' \\\n                          % (entry_stmts, tab + tabchar, k, ','.join(i))\n        body = body + entry_stmts\n    if blocktype == 'block data' and name == '_BLOCK_DATA_':\n        name = ''\n    ret = '%s%s%s %s%s%s %s%s%s%s%s%s%send %s %s' % (\n        tab, prefix, blocktype, name, args, result, mess, f2pyenhancements, use, vars, common, body, tab, blocktype, name)\n    return ret\n\n\ndef common2fortran(common, tab=''):\n    ret = ''\n    for k in list(common.keys()):\n        if k == '_BLNK_':\n            ret = '%s%scommon %s' % (ret, tab, ','.join(common[k]))\n        else:\n            ret = '%s%scommon /%s/ %s' % (ret, tab, k, ','.join(common[k]))\n    return ret\n\n\ndef use2fortran(use, tab=''):\n    ret = ''\n    for m in list(use.keys()):\n        ret = '%s%suse %s,' % (ret, tab, m)\n        if use[m] == {}:\n            if ret and ret[-1] == ',':\n                ret = ret[:-1]\n            continue\n        if 'only' in use[m] and use[m]['only']:\n            ret = '%s only:' % (ret)\n        if 'map' in use[m] and use[m]['map']:\n            c = ' '\n            for k in list(use[m]['map'].keys()):\n                if k == use[m]['map'][k]:\n                    ret = '%s%s%s' % (ret, c, k)\n                    c = ','\n                else:\n                    ret = '%s%s%s=>%s' % (ret, c, k, use[m]['map'][k])\n                    c = ','\n        if ret and ret[-1] == ',':\n            ret = ret[:-1]\n    return ret\n\n\ndef true_intent_list(var):\n    lst = var['intent']\n    ret = []\n    for intent in lst:\n        try:\n            f = globals()['isintent_%s' % intent]\n        except KeyError:\n            pass\n        else:\n            if f(var):\n                ret.append(intent)\n    return ret\n\n\ndef vars2fortran(block, vars, args, tab='', as_interface=False):\n    \"\"\"\n    TODO:\n    public sub\n    ...\n    \"\"\"\n    setmesstext(block)\n    ret = ''\n    nout = []\n    for a in args:\n        if a in block['vars']:\n            nout.append(a)\n    if 'commonvars' in block:\n        for a in block['commonvars']:\n            if a in vars:\n                if a not in nout:\n                    nout.append(a)\n            else:\n                errmess(\n                    'vars2fortran: Confused?!: \"%s\" is not defined in vars.\\n' % a)\n    if 'varnames' in block:\n        nout.extend(block['varnames'])\n    if not as_interface:\n        for a in list(vars.keys()):\n            if a not in nout:\n                nout.append(a)\n    for a in nout:\n        if 'depend' in vars[a]:\n            for d in vars[a]['depend']:\n                if d in vars and 'depend' in vars[d] and a in vars[d]['depend']:\n                    errmess(\n                        'vars2fortran: Warning: cross-dependence between variables \"%s\" and \"%s\"\\n' % (a, d))\n        if 'externals' in block and a in block['externals']:\n            if isintent_callback(vars[a]):\n                ret = '%s%sintent(callback) %s' % (ret, tab, a)\n            ret = '%s%sexternal %s' % (ret, tab, a)\n            if isoptional(vars[a]):\n                ret = '%s%soptional %s' % (ret, tab, a)\n            if a in vars and 'typespec' not in vars[a]:\n                continue\n            cont = 1\n            for b in block['body']:\n                if a == b['name'] and b['block'] == 'function':\n                    cont = 0\n                    break\n            if cont:\n                continue\n        if a not in vars:\n            show(vars)\n            outmess('vars2fortran: No definition for argument \"%s\".\\n' % a)\n            continue\n        if a == block['name']:\n            if block['block'] != 'function' or block.get('result'):\n                # 1) skip declaring a variable that name matches with\n                #    subroutine name\n                # 2) skip declaring function when its type is\n                #    declared via `result` construction\n                continue\n        if 'typespec' not in vars[a]:\n            if 'attrspec' in vars[a] and 'external' in vars[a]['attrspec']:\n                if a in args:\n                    ret = '%s%sexternal %s' % (ret, tab, a)\n                continue\n            show(vars[a])\n            outmess('vars2fortran: No typespec for argument \"%s\".\\n' % a)\n            continue\n        vardef = vars[a]['typespec']\n        if vardef == 'type' and 'typename' in vars[a]:\n            vardef = '%s(%s)' % (vardef, vars[a]['typename'])\n        selector = {}\n        if 'kindselector' in vars[a]:\n            selector = vars[a]['kindselector']\n        elif 'charselector' in vars[a]:\n            selector = vars[a]['charselector']\n        if '*' in selector:\n            if selector['*'] in ['*', ':']:\n                vardef = '%s*(%s)' % (vardef, selector['*'])\n            else:\n                vardef = '%s*%s' % (vardef, selector['*'])\n        else:\n            if 'len' in selector:\n                vardef = '%s(len=%s' % (vardef, selector['len'])\n                if 'kind' in selector:\n                    vardef = '%s,kind=%s)' % (vardef, selector['kind'])\n                else:\n                    vardef = '%s)' % (vardef)\n            elif 'kind' in selector:\n                vardef = '%s(kind=%s)' % (vardef, selector['kind'])\n        c = ' '\n        if 'attrspec' in vars[a]:\n            attr = [l for l in vars[a]['attrspec']\n                    if l not in ['external']]\n            if as_interface and 'intent(in)' in attr and 'intent(out)' in attr:\n                # In Fortran, intent(in, out) are conflicting while\n                # intent(in, out) can be specified only via\n                # `!f2py intent(out) ..`.\n                # So, for the Fortran interface, we'll drop\n                # intent(out) to resolve the conflict.\n                attr.remove('intent(out)')\n            if attr:\n                vardef = '%s, %s' % (vardef, ','.join(attr))\n                c = ','\n        if 'dimension' in vars[a]:\n            vardef = '%s%sdimension(%s)' % (\n                vardef, c, ','.join(vars[a]['dimension']))\n            c = ','\n        if 'intent' in vars[a]:\n            lst = true_intent_list(vars[a])\n            if lst:\n                vardef = '%s%sintent(%s)' % (vardef, c, ','.join(lst))\n            c = ','\n        if 'check' in vars[a]:\n            vardef = '%s%scheck(%s)' % (vardef, c, ','.join(vars[a]['check']))\n            c = ','\n        if 'depend' in vars[a]:\n            vardef = '%s%sdepend(%s)' % (\n                vardef, c, ','.join(vars[a]['depend']))\n            c = ','\n        if '=' in vars[a]:\n            v = vars[a]['=']\n            if vars[a]['typespec'] in ['complex', 'double complex']:\n                try:\n                    v = eval(v)\n                    v = '(%s,%s)' % (v.real, v.imag)\n                except Exception:\n                    pass\n            vardef = '%s :: %s=%s' % (vardef, a, v)\n        else:\n            vardef = '%s :: %s' % (vardef, a)\n        ret = '%s%s%s' % (ret, tab, vardef)\n    return ret\n######\n\n\n# We expose post_processing_hooks as global variable so that\n# user-libraries could register their own hooks to f2py.\npost_processing_hooks = []\n\n\ndef crackfortran(files):\n    global usermodules, post_processing_hooks\n\n    outmess('Reading fortran codes...\\n', 0)\n    readfortrancode(files, crackline)\n    outmess('Post-processing...\\n', 0)\n    usermodules = []\n    postlist = postcrack(grouplist[0])\n    outmess('Applying post-processing hooks...\\n', 0)\n    for hook in post_processing_hooks:\n        outmess(f'  {hook.__name__}\\n', 0)\n        postlist = traverse(postlist, hook)\n    outmess('Post-processing (stage 2)...\\n', 0)\n    postlist = postcrack2(postlist)\n    return usermodules + postlist\n\n\ndef crack2fortran(block):\n    global f2py_version\n\n    pyf = crack2fortrangen(block) + '\\n'\n    header = \"\"\"!    -*- f90 -*-\n! Note: the context of this file is case sensitive.\n\"\"\"\n    footer = \"\"\"\n! This file was auto-generated with f2py (version:%s).\n! See:\n! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e\n\"\"\" % (f2py_version)\n    return header + pyf + footer\n\n\ndef _is_visit_pair(obj):\n    return (isinstance(obj, tuple)\n            and len(obj) == 2\n            and isinstance(obj[0], (int, str)))\n\n\ndef traverse(obj, visit, parents=[], result=None, *args, **kwargs):\n    '''Traverse f2py data structure with the following visit function:\n\n    def visit(item, parents, result, *args, **kwargs):\n        \"\"\"\n\n        parents is a list of key-\"f2py data structure\" pairs from which\n        items are taken from.\n\n        result is a f2py data structure that is filled with the\n        return value of the visit function.\n\n        item is 2-tuple (index, value) if parents[-1][1] is a list\n        item is 2-tuple (key, value) if parents[-1][1] is a dict\n\n        The return value of visit must be None, or of the same kind as\n        item, that is, if parents[-1] is a list, the return value must\n        be 2-tuple (new_index, new_value), or if parents[-1] is a\n        dict, the return value must be 2-tuple (new_key, new_value).\n\n        If new_index or new_value is None, the return value of visit\n        is ignored, that is, it will not be added to the result.\n\n        If the return value is None, the content of obj will be\n        traversed, otherwise not.\n        \"\"\"\n    '''\n\n    if _is_visit_pair(obj):\n        if obj[0] == 'parent_block':\n            # avoid infinite recursion\n            return obj\n        new_result = visit(obj, parents, result, *args, **kwargs)\n        if new_result is not None:\n            assert _is_visit_pair(new_result)\n            return new_result\n        parent = obj\n        result_key, obj = obj\n    else:\n        parent = (None, obj)\n        result_key = None\n\n    if isinstance(obj, list):\n        new_result = []\n        for index, value in enumerate(obj):\n            new_index, new_item = traverse((index, value), visit,\n                                           parents=parents + [parent],\n                                           result=result, *args, **kwargs)\n            if new_index is not None:\n                new_result.append(new_item)\n    elif isinstance(obj, dict):\n        new_result = dict()\n        for key, value in obj.items():\n            new_key, new_value = traverse((key, value), visit,\n                                          parents=parents + [parent],\n                                          result=result, *args, **kwargs)\n            if new_key is not None:\n                new_result[new_key] = new_value\n    else:\n        new_result = obj\n\n    if result_key is None:\n        return new_result\n    return result_key, new_result\n\n\ndef character_backward_compatibility_hook(item, parents, result,\n                                          *args, **kwargs):\n    \"\"\"Previously, Fortran character was incorrectly treated as\n    character*1. This hook fixes the usage of the corresponding\n    variables in `check`, `dimension`, `=`, and `callstatement`\n    expressions.\n\n    The usage of `char*` in `callprotoargument` expression can be left\n    unchanged because C `character` is C typedef of `char`, although,\n    new implementations should use `character*` in the corresponding\n    expressions.\n\n    See https://github.com/numpy/numpy/pull/19388 for more information.\n\n    \"\"\"\n    parent_key, parent_value = parents[-1]\n    key, value = item\n\n    def fix_usage(varname, value):\n        value = re.sub(r'[*]\\s*\\b' + varname + r'\\b', varname, value)\n        value = re.sub(r'\\b' + varname + r'\\b\\s*[\\[]\\s*0\\s*[\\]]',\n                       varname, value)\n        return value\n\n    if parent_key in ['dimension', 'check']:\n        assert parents[-3][0] == 'vars'\n        vars_dict = parents[-3][1]\n    elif key == '=':\n        assert parents[-2][0] == 'vars'\n        vars_dict = parents[-2][1]\n    else:\n        vars_dict = None\n\n    new_value = None\n    if vars_dict is not None:\n        new_value = value\n        for varname, vd in vars_dict.items():\n            if ischaracter(vd):\n                new_value = fix_usage(varname, new_value)\n    elif key == 'callstatement':\n        vars_dict = parents[-2][1]['vars']\n        new_value = value\n        for varname, vd in vars_dict.items():\n            if ischaracter(vd):\n                # replace all occurrences of `<varname>` with\n                # `&<varname>` in argument passing\n                new_value = re.sub(\n                    r'(?<![&])\\b' + varname + r'\\b', '&' + varname, new_value)\n\n    if new_value is not None:\n        if new_value != value:\n            # We report the replacements here so that downstream\n            # software could update their source codes\n            # accordingly. However, such updates are recommended only\n            # when BC with numpy 1.21 or older is not required.\n            outmess(f'character_bc_hook[{parent_key}.{key}]:'\n                    f' replaced `{value}` -> `{new_value}`\\n', 1)\n        return (key, new_value)\n\n\npost_processing_hooks.append(character_backward_compatibility_hook)\n\n\nif __name__ == \"__main__\":\n    files = []\n    funcs = []\n    f = 1\n    f2 = 0\n    f3 = 0\n    showblocklist = 0\n    for l in sys.argv[1:]:\n        if l == '':\n            pass\n        elif l[0] == ':':\n            f = 0\n        elif l == '-quiet':\n            quiet = 1\n            verbose = 0\n        elif l == '-verbose':\n            verbose = 2\n            quiet = 0\n        elif l == '-fix':\n            if strictf77:\n                outmess(\n                    'Use option -f90 before -fix if Fortran 90 code is in fix form.\\n', 0)\n            skipemptyends = 1\n            sourcecodeform = 'fix'\n        elif l == '-skipemptyends':\n            skipemptyends = 1\n        elif l == '--ignore-contains':\n            ignorecontains = 1\n        elif l == '-f77':\n            strictf77 = 1\n            sourcecodeform = 'fix'\n        elif l == '-f90':\n            strictf77 = 0\n            sourcecodeform = 'free'\n            skipemptyends = 1\n        elif l == '-h':\n            f2 = 1\n        elif l == '-show':\n            showblocklist = 1\n        elif l == '-m':\n            f3 = 1\n        elif l[0] == '-':\n            errmess('Unknown option %s\\n' % repr(l))\n        elif f2:\n            f2 = 0\n            pyffilename = l\n        elif f3:\n            f3 = 0\n            f77modulename = l\n        elif f:\n            try:\n                open(l).close()\n                files.append(l)\n            except OSError as detail:\n                errmess(f'OSError: {detail!s}\\n')\n        else:\n            funcs.append(l)\n    if not strictf77 and f77modulename and not skipemptyends:\n        outmess(\"\"\"\\\n  Warning: You have specified module name for non Fortran 77 code that\n  should not need one (expect if you are scanning F90 code for non\n  module blocks but then you should use flag -skipemptyends and also\n  be sure that the files do not contain programs without program\n  statement).\n\"\"\", 0)\n\n    postlist = crackfortran(files)\n    if pyffilename:\n        outmess('Writing fortran code to file %s\\n' % repr(pyffilename), 0)\n        pyf = crack2fortran(postlist)\n        with open(pyffilename, 'w') as f:\n            f.write(pyf)\n    if showblocklist:\n        show(postlist)\n",
            "fixNo": "IL-M-3",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a module is imported using the wildcard symbol. This will import <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>public name from this module</a> and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py2547899261578704767.diff"
            ]
        },
        {
            "fixerCustomHeading": "Avoid Wildcard Imports",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/f90mod_rules.py",
            "fixerCategoryTag": "PyCSI-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:27 UTC 2024",
            "fixerCustomMessageText": "In file: f90mod_rules.py, a module is imported using the wildcard symbol. This will import public name from this module and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "#!/usr/bin/env python3\n\"\"\"\n\nBuild F90 module support for f2py2e.\n\nCopyright 2000 Pearu Peterson all rights reserved,\nPearu Peterson <pearu@ioc.ee>\nPermission to use, modify, and distribute this software is given under the\nterms of the NumPy License.\n\nNO WARRANTY IS EXPRESSED OR IMPLIED.  USE AT YOUR OWN RISK.\n$Date: 2005/02/03 19:30:23 $\nPearu Peterson\n\n\"\"\"\n__version__ = \"$Revision: 1.27 $\"[10:-1]\n\nf2py_version = 'See `f2py -v`'\n\nimport numpy as np\n\nfrom . import capi_maps\nfrom . import func2subr\nfrom .crackfortran import undo_rmbadname, undo_rmbadname1\n\n# The environment provided by auxfuncs.py is needed for some calls to eval.\n# As the needed functions cannot be determined by static inspection of the\n# code, it is safest to use import * pending a major refactoring of f2py.\n# OpenRefactory Warning: Importing every public name using star import should be avoided.\nfrom .auxfuncs import *\n\noptions = {}\n\n\ndef findf90modules(m):\n    if ismodule(m):\n        return [m]\n    if not hasbody(m):\n        return []\n    ret = []\n    for b in m['body']:\n        if ismodule(b):\n            ret.append(b)\n        else:\n            ret = ret + findf90modules(b)\n    return ret\n\nfgetdims1 = \"\"\"\\\n      external f2pysetdata\n      logical ns\n      integer r,i\n      integer(%d) s(*)\n      ns = .FALSE.\n      if (allocated(d)) then\n         do i=1,r\n            if ((size(d,i).ne.s(i)).and.(s(i).ge.0)) then\n               ns = .TRUE.\n            end if\n         end do\n         if (ns) then\n            deallocate(d)\n         end if\n      end if\n      if ((.not.allocated(d)).and.(s(1).ge.1)) then\"\"\" % np.intp().itemsize\n\nfgetdims2 = \"\"\"\\\n      end if\n      if (allocated(d)) then\n         do i=1,r\n            s(i) = size(d,i)\n         end do\n      end if\n      flag = 1\n      call f2pysetdata(d,allocated(d))\"\"\"\n\nfgetdims2_sa = \"\"\"\\\n      end if\n      if (allocated(d)) then\n         do i=1,r\n            s(i) = size(d,i)\n         end do\n         !s(r) must be equal to len(d(1))\n      end if\n      flag = 2\n      call f2pysetdata(d,allocated(d))\"\"\"\n\n\ndef buildhooks(pymod):\n    from . import rules\n    ret = {'f90modhooks': [], 'initf90modhooks': [], 'body': [],\n           'need': ['F_FUNC', 'arrayobject.h'],\n           'separatorsfor': {'includes0': '\\n', 'includes': '\\n'},\n           'docs': ['\"Fortran 90/95 modules:\\\\n\"'],\n           'latexdoc': []}\n    fhooks = ['']\n\n    def fadd(line, s=fhooks):\n        s[0] = '%s\\n      %s' % (s[0], line)\n    doc = ['']\n\n    def dadd(line, s=doc):\n        s[0] = '%s\\n%s' % (s[0], line)\n    for m in findf90modules(pymod):\n        sargs, fargs, efargs, modobjs, notvars, onlyvars = [], [], [], [], [\n            m['name']], []\n        sargsp = []\n        ifargs = []\n        mfargs = []\n        if hasbody(m):\n            for b in m['body']:\n                notvars.append(b['name'])\n        for n in m['vars'].keys():\n            var = m['vars'][n]\n            if (n not in notvars) and (not l_or(isintent_hide, isprivate)(var)):\n                onlyvars.append(n)\n                mfargs.append(n)\n        outmess('\\t\\tConstructing F90 module support for \"%s\"...\\n' %\n                (m['name']))\n        if onlyvars:\n            outmess('\\t\\t  Variables: %s\\n' % (' '.join(onlyvars)))\n        chooks = ['']\n\n        def cadd(line, s=chooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n        ihooks = ['']\n\n        def iadd(line, s=ihooks):\n            s[0] = '%s\\n%s' % (s[0], line)\n\n        vrd = capi_maps.modsign2map(m)\n        cadd('static FortranDataDef f2py_%s_def[] = {' % (m['name']))\n        dadd('\\\\subsection{Fortran 90/95 module \\\\texttt{%s}}\\n' % (m['name']))\n        if hasnote(m):\n            note = m['note']\n            if isinstance(note, list):\n                note = '\\n'.join(note)\n            dadd(note)\n        if onlyvars:\n            dadd('\\\\begin{description}')\n        for n in onlyvars:\n            var = m['vars'][n]\n            modobjs.append(n)\n            ct = capi_maps.getctype(var)\n            at = capi_maps.c2capi_map[ct]\n            dm = capi_maps.getarrdims(n, var)\n            dms = dm['dims'].replace('*', '-1').strip()\n            dms = dms.replace(':', '-1').strip()\n            if not dms:\n                dms = '-1'\n            use_fgetdims2 = fgetdims2\n            cadd('\\t{\"%s\",%s,{{%s}},%s, %s},' %\n                 (undo_rmbadname1(n), dm['rank'], dms, at,\n                  capi_maps.get_elsize(var)))\n            dadd('\\\\item[]{{}\\\\verb@%s@{}}' %\n                 (capi_maps.getarrdocsign(n, var)))\n            if hasnote(var):\n                note = var['note']\n                if isinstance(note, list):\n                    note = '\\n'.join(note)\n                dadd('--- %s' % (note))\n            if isallocatable(var):\n                fargs.append('f2py_%s_getdims_%s' % (m['name'], n))\n                efargs.append(fargs[-1])\n                sargs.append(\n                    'void (*%s)(int*,int*,void(*)(char*,int*),int*)' % (n))\n                sargsp.append('void (*)(int*,int*,void(*)(char*,int*),int*)')\n                iadd('\\tf2py_%s_def[i_f2py++].func = %s;' % (m['name'], n))\n                fadd('subroutine %s(r,s,f2pysetdata,flag)' % (fargs[-1]))\n                fadd('use %s, only: d => %s\\n' %\n                     (m['name'], undo_rmbadname1(n)))\n                fadd('integer flag\\n')\n                fhooks[0] = fhooks[0] + fgetdims1\n                dms = range(1, int(dm['rank']) + 1)\n                fadd(' allocate(d(%s))\\n' %\n                     (','.join(['s(%s)' % i for i in dms])))\n                fhooks[0] = fhooks[0] + use_fgetdims2\n                fadd('end subroutine %s' % (fargs[-1]))\n            else:\n                fargs.append(n)\n                sargs.append('char *%s' % (n))\n                sargsp.append('char*')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' % (m['name'], n))\n        if onlyvars:\n            dadd('\\\\end{description}')\n        if hasbody(m):\n            for b in m['body']:\n                if not isroutine(b):\n                    outmess(\"f90mod_rules.buildhooks:\"\n                            f\" skipping {b['block']} {b['name']}\\n\")\n                    continue\n                modobjs.append('%s()' % (b['name']))\n                b['modulename'] = m['name']\n                api, wrap = rules.buildapi(b)\n                if isfunction(b):\n                    fhooks[0] = fhooks[0] + wrap\n                    fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                    ifargs.append(func2subr.createfuncwrapper(b, signature=1))\n                else:\n                    if wrap:\n                        fhooks[0] = fhooks[0] + wrap\n                        fargs.append('f2pywrap_%s_%s' % (m['name'], b['name']))\n                        ifargs.append(\n                            func2subr.createsubrwrapper(b, signature=1))\n                    else:\n                        fargs.append(b['name'])\n                        mfargs.append(fargs[-1])\n                api['externroutines'] = []\n                ar = applyrules(api, vrd)\n                ar['docs'] = []\n                ar['docshort'] = []\n                ret = dictappend(ret, ar)\n                cadd(('\\t{\"%s\",-1,{{-1}},0,0,NULL,(void *)'\n                      'f2py_rout_#modulename#_%s_%s,'\n                      'doc_f2py_rout_#modulename#_%s_%s},')\n                     % (b['name'], m['name'], b['name'], m['name'], b['name']))\n                sargs.append('char *%s' % (b['name']))\n                sargsp.append('char *')\n                iadd('\\tf2py_%s_def[i_f2py++].data = %s;' %\n                     (m['name'], b['name']))\n        cadd('\\t{NULL}\\n};\\n')\n        iadd('}')\n        ihooks[0] = 'static void f2py_setup_%s(%s) {\\n\\tint i_f2py=0;%s' % (\n            m['name'], ','.join(sargs), ihooks[0])\n        if '_' in m['name']:\n            F_FUNC = 'F_FUNC_US'\n        else:\n            F_FUNC = 'F_FUNC'\n        iadd('extern void %s(f2pyinit%s,F2PYINIT%s)(void (*)(%s));'\n             % (F_FUNC, m['name'], m['name'].upper(), ','.join(sargsp)))\n        iadd('static void f2py_init_%s(void) {' % (m['name']))\n        iadd('\\t%s(f2pyinit%s,F2PYINIT%s)(f2py_setup_%s);'\n             % (F_FUNC, m['name'], m['name'].upper(), m['name']))\n        iadd('}\\n')\n        ret['f90modhooks'] = ret['f90modhooks'] + chooks + ihooks\n        ret['initf90modhooks'] = ['\\tPyDict_SetItemString(d, \"%s\", PyFortranObject_New(f2py_%s_def,f2py_init_%s));' % (\n            m['name'], m['name'], m['name'])] + ret['initf90modhooks']\n        fadd('')\n        fadd('subroutine f2pyinit%s(f2pysetupfunc)' % (m['name']))\n        if mfargs:\n            for a in undo_rmbadname(mfargs):\n                fadd('use %s, only : %s' % (m['name'], a))\n        if ifargs:\n            fadd(' '.join(['interface'] + ifargs))\n            fadd('end interface')\n        fadd('external f2pysetupfunc')\n        if efargs:\n            for a in undo_rmbadname(efargs):\n                fadd('external %s' % (a))\n        fadd('call f2pysetupfunc(%s)' % (','.join(undo_rmbadname(fargs))))\n        fadd('end subroutine f2pyinit%s\\n' % (m['name']))\n\n        dadd('\\n'.join(ret['latexdoc']).replace(\n            r'\\subsection{', r'\\subsubsection{'))\n\n        ret['latexdoc'] = []\n        ret['docs'].append('\"\\t%s --- %s\"' % (m['name'],\n                                              ','.join(undo_rmbadname(modobjs))))\n\n    ret['routine_defs'] = ''\n    ret['doc'] = []\n    ret['docshort'] = []\n    ret['latexdoc'] = doc[0]\n    if len(ret['docs']) <= 1:\n        ret['docs'] = ''\n    return ret, fhooks[0]\n",
            "fixNo": "IL-M-4",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>f90mod_rules.py</span>, a module is imported using the wildcard symbol. This will import <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>public name from this module</a> and can create conflicts in the local namespace. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "f90mod_rules.py6555426280509569982.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "readfortrancode",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('readfortrancode: could not find include file %s in %s. Ignoring.\\n' % (\n                        repr(fn), os.pathsep.join(include_dirs)))",
            "fixNo": "IL-M-5",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py1784284045792477709.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('crackline:%d: No pattern for line\\n' % (groupcounter))",
            "fixNo": "IL-M-6",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py17374370149024652278.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('All arguments will have attribute %s%s\\n' %\n                        (m.group('this'), ll[:i]))",
            "fixNo": "IL-M-7",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py2171025540349791487.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "determineexprtype",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                'determineexprtype: selected kind types not supported (%s)\\n' % repr(expr))",
            "fixNo": "IL-M-8",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py12443557753530562908.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: No context for multiline block.\\n')",
            "fixNo": "IL-M-9",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py8762895732700487400.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                        'analyzeline: implied-DO list \"%s\" is not supported. Skipping.\\n' % v)",
            "fixNo": "IL-M-10",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py5736080050546719808.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "vars2fortran",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('vars2fortran: No definition for argument \"%s\".\\n' % a)",
            "fixNo": "IL-M-11",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py5398152418035347373.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackfortran",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('Post-processing...\\n', 0)",
            "fixNo": "IL-M-12",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py16504592843776894384.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "cracktypespec0",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n            'cracktypespec0: no kind/char_selector pattern found for line.\\n')",
            "fixNo": "IL-M-13",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py15406620033377099000.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "determineexprtype",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                'determineexprtype: selected kind types not supported (%s)\\n' % repr(expr))",
            "fixNo": "IL-M-14",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py3215204835150153910.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\"\"\"\\\n  Warning: You have specified module name for non Fortran 77 code that\n  should not need one (expect if you are scanning F90 code for non\n  module blocks but then you should use flag -skipemptyends and also\n  be sure that the files do not contain programs without program\n  statement).\n\"\"\", 0)",
            "fixNo": "IL-M-15",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py10101517363201181231.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "updatevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('updatevars: attempt to change the kindselector \"%s\" of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                            k, ename, edecl['kindselector'][k], kindselect[k]))",
            "fixNo": "IL-M-16",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py14053383915257338869.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "updatevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('updatevars: could not crack entity declaration \"%s\". Ignoring.\\n' % (\n                    ename + m.group('after')))",
            "fixNo": "IL-M-17",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py9414331349445203905.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "character_backward_compatibility_hook",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(f'character_bc_hook[{parent_key}.{key}]:'\n                    f' replaced `{value}` -> `{new_value}`\\n', 1)",
            "fixNo": "IL-M-18",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py4420162466336224696.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "cracktypespec",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                    'cracktypespec: no kindselector pattern found for %s\\n' % (repr(selector)))",
            "fixNo": "IL-M-19",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py4445782083487224899.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "updatevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                'updatevars: no name pattern found for entity=%s. Skipping.\\n' % (repr(e)))",
            "fixNo": "IL-M-20",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py2509593326691963486.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                            'crackline: could not resolve function call for line=%s.\\n' % repr(line))",
            "fixNo": "IL-M-21",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py15303010235019282709.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "buildimplicitrules",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                    'buildimplicitrules: no implicit rules for routine %s.\\n' % repr(block['name']))",
            "fixNo": "IL-M-22",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py14612032522630606353.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n            'analyzeline: no group yet. Creating program group with name \"%s\".\\n' % newname)",
            "fixNo": "IL-M-23",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py555730124552622326.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "postcrack",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('%sBlock: %s\\n' % (tab, block['name']), 0)",
            "fixNo": "IL-M-24",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py3611026187586865474.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                'crackline: Mismatch of blocks encountered. Trying to fix it by assuming \"end\" statement.\\n')",
            "fixNo": "IL-M-25",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py9080618421226562371.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                            'analyzevars: prefix (%s) were not used\\n' % repr(block['prefix']))",
            "fixNo": "IL-M-26",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py14290892913672529166.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('Writing fortran code to file %s\\n' % repr(pyffilename), 0)",
            "fixNo": "IL-M-27",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py10919263345150083166.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "updatevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('updatevars: attempt to change the init expression of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                            ename, edecl['='], d1['init']))",
            "fixNo": "IL-M-28",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py12308570712387871094.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "get_parameters",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('get_parameters: got \"%s\" on %s\\n' % (msg, repr(v)))",
            "fixNo": "IL-M-29",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py11554293292892594865.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "cracktypespec",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                    'cracktypespec: no charselector pattern found for %s\\n' % (repr(selector)))",
            "fixNo": "IL-M-30",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py3343861536155523458.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                        'analyzeline: could not extract info of implicit statement part \"%s\"\\n' % (e))",
            "fixNo": "IL-M-31",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py7491182729733297581.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackfortran",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('Reading fortran codes...\\n', 0)",
            "fixNo": "IL-M-32",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py13437607881422320543.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackfortran",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(f'  {hook.__name__}\\n', 0)",
            "fixNo": "IL-M-33",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py430397625351464070.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "determineexprtype",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n            'determineexprtype: could not determine expressions (%s) type.\\n' % (repr(expr)))",
            "fixNo": "IL-M-34",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py13185109107909892306.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "updatevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('updatevars: attempt to change the type of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                    ename, edecl['typespec'], typespec))",
            "fixNo": "IL-M-35",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py1385432638848755600.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: Overwriting the value of parameter \"%s\" (\"%s\") with \"%s\".\\n' % (\n                    k, edecl[k]['='], initexpr))",
            "fixNo": "IL-M-36",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py15591627852797532545.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: changing init expression of \"%s\" (\"%s\") to \"%s\"\\n' % (\n                        v, vars[v]['='], l[1][j:i - 1]))",
            "fixNo": "IL-M-37",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py11152421829809277707.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                    'analyzeline: implied-DO list \"%s\" is not supported. Skipping.\\n' % l[0])",
            "fixNo": "IL-M-38",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py2822396204713470284.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: Creating module block %s\\n' %\n                        repr(f77modulename), 0)",
            "fixNo": "IL-M-39",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py16825284396729917239.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                        'analyzeline: could not extract types pattern of implicit statement part \"%s\"\\n' % (e))",
            "fixNo": "IL-M-40",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py11122923593344614693.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "_get_depend_dict",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('_get_depend_dict: no dependence info for %s\\n' % (repr(name)))",
            "fixNo": "IL-M-41",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py15475815768893716714.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: no name pattern found in %s statement for %s. Skipping.\\n' % (\n                        case, repr(e)))",
            "fixNo": "IL-M-42",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py10659510697813321491.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: ignoring program arguments\\n')",
            "fixNo": "IL-M-43",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py6788313880026923152.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "get_useparameters",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('get_useparameters: no module %s info used by %s\\n' %\n                    (usename, block.get('name')))",
            "fixNo": "IL-M-44",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py7563704142781653926.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                    'analyzeline: Overwriting earlier \"implicit none\" statement.\\n')",
            "fixNo": "IL-M-45",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py1218347890151828846.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "cracktypespec",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('cracktypespec: no selector used for %s\\n' %\n                    (repr(selector)))",
            "fixNo": "IL-M-46",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py8333221600521181144.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                            'analyzeline: expected \"<char>-<char>\" instead of \"%s\" in range list of implicit statement (2)\\n' % r)",
            "fixNo": "IL-M-47",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py18002114104880193538.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                    'Use option -f90 before -fix if Fortran 90 code is in fix form.\\n', 0)",
            "fixNo": "IL-M-48",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py11797430451433986077.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackfortran",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('Post-processing (stage 2)...\\n', 0)",
            "fixNo": "IL-M-49",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py12099892228738215490.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "readfortrancode",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('readfortrancode: could not find include file %s in %s. Ignoring.\\n' % (\n                    repr(fn), os.pathsep.join(include_dirs)))",
            "fixNo": "IL-M-50",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py16568541313675488150.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: appending intent(callback) %s'\n                                        ' to %s arguments\\n' % (k, groupcache[groupcounter]['name']))",
            "fixNo": "IL-M-51",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py16244766512634005547.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackfortran",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('Applying post-processing hooks...\\n', 0)",
            "fixNo": "IL-M-52",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py10191905432209439629.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: Could not crack the use statement.\\n')",
            "fixNo": "IL-M-53",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py13780037814582592959.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "readfortrancode",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('\\tReading file %s (format:%s%s)\\n'\n                    % (repr(currentfilename), sourcecodeform,\n                       strictf77 and ',strict' or ''))",
            "fixNo": "IL-M-54",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py16629754050098425559.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "crackline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('crackline: groupcounter=%s groupname=%s\\n' %\n                    (repr(groupcounter), repr(groupname)))",
            "fixNo": "IL-M-55",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py4884220827860930764.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzevars: typespec of variable %s is not defined in routine %s.\\n' % (\n                        repr(n), block['name']))",
            "fixNo": "IL-M-56",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py17851619699561053598.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "updatevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('updatevars: attempt to change the charselector \"%s\" of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                            k, ename, edecl['charselector'][k], charselect[k]))",
            "fixNo": "IL-M-57",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py2485412946476703395.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                                'analyzeline: Not local=>use pattern found in %s\\n' % repr(l))",
            "fixNo": "IL-M-58",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py1912942449025417390.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                                    'analyzeline: missing __user__ module (could be nothing)\\n')",
            "fixNo": "IL-M-59",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py16123889524752264493.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                    'analyzeline: could not extract name,expr in parameter statement \"%s\" of \"%s\"\\n' % (e, ll))",
            "fixNo": "IL-M-60",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py14967561587026913417.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: cannot handle multiple attributes without type specification. Ignoring %r.\\n' % (\n                ','.join(ch[1:])))",
            "fixNo": "IL-M-61",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py3412625100412170236.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                                'analyzeline: expected \"<char>-<char>\" instead of \"%s\" in range list of implicit statement\\n' % r)",
            "fixNo": "IL-M-62",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py13582573439128146240.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: Creating additional interface block (groupcounter=%s).\\n' % (\n                    groupcounter), 0)",
            "fixNo": "IL-M-63",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py3906641973623699414.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "get_parameters",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                'get_parameters:parameter %s does not have value?!\\n' % (repr(n)))",
            "fixNo": "IL-M-64",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py17732802057879556040.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: No name/args pattern found for line.\\n')",
            "fixNo": "IL-M-65",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py12420029242505135290.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "postcrack2",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('%sBlock: %s\\n' % (tab, block['name']), 0)",
            "fixNo": "IL-M-66",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py17418108053393800508.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "get_parameters",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(f'get_parameters[TODO]: '\n                        f'implement evaluation of complex expression {v}\\n')",
            "fixNo": "IL-M-67",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py17192977861346061341.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "vars2fortran",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('vars2fortran: No typespec for argument \"%s\".\\n' % a)",
            "fixNo": "IL-M-68",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py6971186817733629215.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "cracktypespec",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('cracktypespec: no typename found in %s\\n' %\n                        (repr(typespec + selector)))",
            "fixNo": "IL-M-69",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py14169874293140828893.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess(\n                'analyzeline: argument list is malformed (missing argument).\\n')",
            "fixNo": "IL-M-70",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py13107332473218492738.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "get_useparameters",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('get_useparameters: overriding parameter %s with'\n                        ' value from module %s\\n' % (repr(k), repr(usename)))",
            "fixNo": "IL-M-71",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py17502714137096510933.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('analyzeline: No code implemented for line.\\n')",
            "fixNo": "IL-M-72",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py8099367390036350972.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "updatevars",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "outmess('updatevars: attempt to change the typename of \"%s\" (\"%s\") to \"%s\". Ignoring.\\n' % (\n                    ename, edecl['typename'], typename))",
            "fixNo": "IL-M-73",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "crackfortran.py16227388273926460076.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "set_verbosity",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/log.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:43 UTC 2024",
            "fixerCustomMessageText": "In file: log.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "set_threshold(ERROR, force)",
            "fixNo": "IL-M-74",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>log.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "log.py547832536449063523.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/log.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:43 UTC 2024",
            "fixerCustomMessageText": "In file: log.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "set_verbosity(0, force=True)",
            "fixNo": "IL-M-75",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>log.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "log.py3296743762665231484.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "set_verbosity",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/log.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:43 UTC 2024",
            "fixerCustomMessageText": "In file: log.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "set_threshold(WARN, force)",
            "fixNo": "IL-M-76",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>log.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "log.py670328016012210977.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "set_threshold",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/log.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:43 UTC 2024",
            "fixerCustomMessageText": "In file: log.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "info('set_threshold: not changing threshold from DEBUG level'\n                ' %s to %s' % (prev_level, level))",
            "fixNo": "IL-M-77",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>log.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "log.py3331667546877051349.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "set_threshold",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/log.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:43 UTC 2024",
            "fixerCustomMessageText": "In file: log.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "info('set_threshold: setting threshold to DEBUG level,'\n                    ' it can be changed only with force argument')",
            "fixNo": "IL-M-78",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>log.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "log.py11083030256229740015.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "set_verbosity",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/log.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:43 UTC 2024",
            "fixerCustomMessageText": "In file: log.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "set_threshold(DEBUG, force)",
            "fixNo": "IL-M-79",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>log.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "log.py5286234508918877275.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "set_verbosity",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/log.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:43 UTC 2024",
            "fixerCustomMessageText": "In file: log.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "set_threshold(INFO, force)",
            "fixNo": "IL-M-80",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>log.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "log.py3139793718393970724.diff"
            ]
        },
        {
            "fixerCustomHeading": "Check Shadowing Of Imported Symbol",
            "isWarning": "True",
            "functionName": "identity",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/matlib.py",
            "fixerCategoryTag": "PyCSI-2",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:01:20 UTC 2024",
            "fixerCustomMessageText": "In file: matlib.py, a method has been imported wildcard symbol where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "empty((n, n), dtype=dtype)",
            "fixNo": "IL-M-81",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>matlib.py</span>, a method has been imported <a href='https://docs.python.org/3.8/reference/simple_stmts.html#import' target='_blank'>wildcard symbol</a> where there is also a local definition of it.  The local definition shadows the imported one which can lead to unintended behavior. iCR suggested that wildcard imports should be avoided.",
            "diffLocations": [
                "matlib.py16300481136372172755.diff"
            ]
        },
        {
            "fixerCustomHeading": "Fix Argument Swap",
            "isWarning": "False",
            "functionName": "test_99",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/ma/timer_comparison.py",
            "fixerCategoryTag": "PyFAS-1",
            "className": "ModuleTester",
            "priority": "M",
            "scanDate": "Thu Feb 29 08:57:41 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method test_99 there is a call to a method in which the arguments are passed in the wrong order. This may change the outcome of the program. iCR swapped the method arguments to follow the proper order.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "self.assert_array_equal(result, 2.0)",
            "fixNo": "IL-M-82",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>test_99</span> there is a call to a method in which the arguments are passed in the wrong order. This may change the outcome of the program. iCR swapped the method arguments to follow the proper order.",
            "diffLocations": [
                "timer_comparison.py6539288031227847940.diff"
            ]
        },
        {
            "fixerCustomHeading": "Fix Argument Swap",
            "isWarning": "False",
            "functionName": "matcher",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/ccompiler.py",
            "fixerCategoryTag": "PyFAS-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:58 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method matcher there is a call to a method in which the arguments are passed in the wrong order. This may change the outcome of the program. iCR swapped the method arguments to follow the proper order.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "re.match(version_string, start)",
            "fixNo": "IL-M-83",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>matcher</span> there is a call to a method in which the arguments are passed in the wrong order. This may change the outcome of the program. iCR swapped the method arguments to follow the proper order.",
            "diffLocations": [
                "ccompiler.py15148517064994453323.diff"
            ]
        },
        {
            "fixerCustomHeading": "Fix Inappropriate Binary Operator",
            "isWarning": "True",
            "functionName": "check_funcs_once",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/command/config.py",
            "fixerCategoryTag": "PyFIBO-1",
            "className": "config",
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:44 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method check_funcs_once there is a binary operation in which the operator may be used wrongly. iCR suggested that a different binary operator should be used.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "f in call",
            "fixNo": "IL-M-84",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>check_funcs_once</span> there is a binary operation in which the operator may be used wrongly. iCR suggested that a different binary operator should be used.",
            "diffLocations": [
                "config.py8366353555713355121.diff"
            ]
        },
        {
            "fixerCustomHeading": "Fix Inappropriate Operator",
            "isWarning": "True",
            "functionName": "add_newdoc_for_scalar_type",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/_add_newdocs_scalars.py",
            "fixerCategoryTag": "PyFIO-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:33 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method add_newdoc_for_scalar_type there is a binary operation in which the operand may be used wrongly. iCR suggested that a different operand should be used.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "obj == o.__name__",
            "fixNo": "IL-M-85",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>add_newdoc_for_scalar_type</span> there is a binary operation in which the operand may be used wrongly. iCR suggested that a different operand should be used.",
            "diffLocations": [
                "_add_newdocs_scalars.py11054016786206813354.diff"
            ]
        },
        {
            "fixerCustomHeading": "Fix Inappropriate Operator",
            "isWarning": "True",
            "functionName": "_normed_hermite_n",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/polynomial/hermite.py",
            "fixerCategoryTag": "PyFIO-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:01:22 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method _normed_hermite_n there is a binary operation in which the operand may be used wrongly. iCR suggested that a different operand should be used.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "nd - 1.",
            "fixNo": "IL-M-86",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>_normed_hermite_n</span> there is a binary operation in which the operand may be used wrongly. iCR suggested that a different operand should be used.",
            "diffLocations": [
                "hermite.py17184713073867960650.diff"
            ]
        },
        {
            "fixerCustomHeading": "Fix Inappropriate Operator",
            "isWarning": "True",
            "functionName": "_normed_hermite_e_n",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/polynomial/hermite_e.py",
            "fixerCategoryTag": "PyFIO-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:01:27 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method _normed_hermite_e_n there is a binary operation in which the operand may be used wrongly. iCR suggested that a different operand should be used.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "nd - 1.",
            "fixNo": "IL-M-87",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>_normed_hermite_e_n</span> there is a binary operation in which the operand may be used wrongly. iCR suggested that a different operand should be used.",
            "diffLocations": [
                "hermite_e.py12574456911359005838.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "_get_bin_edges",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/lib/histograms.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:57:51 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method _get_bin_edges a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "ndim == 0",
            "fixNo": "IL-M-88",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>_get_bin_edges</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "histograms.py12020934086278872236.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "histogramdd",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/lib/histograms.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:57:51 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method histogramdd a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "ndim == 0",
            "fixNo": "IL-M-89",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>histogramdd</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "histograms.py461925450917769841.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "format_array",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/arrayprint.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": "SubArrayFormat",
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:15 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method format_array a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "[self.format_array(a_) for a_ in a[:self.edge_items]]\n                + [self.summary_insert]\n                + [self.format_array(a_) for a_ in a[-self.edge_items:]]",
            "fixNo": "IL-M-90",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>format_array</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "arrayprint.py10796694329711162423.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "getarrdims",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/capi_maps.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:45 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method getarrdims a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "isstring(var) and not array",
            "fixNo": "IL-M-91",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>getarrdims</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "capi_maps.py11958960258427365323.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "getarrdocsign",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/capi_maps.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:45 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method getarrdocsign a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "isstring(var) and (not array)",
            "fixNo": "IL-M-92",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>getarrdocsign</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "capi_maps.py3687571857133784122.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method analyzeline a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "result_var == 'real'",
            "fixNo": "IL-M-93",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>analyzeline</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "crackfortran.py7564634866324174642.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "readfortrancode",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method readfortrancode a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "Path(currentfilename).suffix.lower() in COMMON_FIXED_EXTENSIONS and \\\n                    not (_has_f90_header(l) or has_fix_header)",
            "fixNo": "IL-M-94",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>readfortrancode</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "crackfortran.py5783328347244964657.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "analyzeline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method analyzeline a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "group.strip().lower() == 'none'",
            "fixNo": "IL-M-95",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>analyzeline</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "crackfortran.py2202071613873508918.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "get_libraries",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/fcompiler/absoft.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": "AbsoftFCompiler",
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:53 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method get_libraries a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "version >= '11.0'",
            "fixNo": "IL-M-96",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>get_libraries</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "absoft.py14854812380875611419.diff"
            ]
        },
        {
            "fixerCustomHeading": "Refactor Redundant Method Call",
            "isWarning": "True",
            "functionName": "calc_info",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/distutils/system_info.py",
            "fixerCategoryTag": "PyFRMC-1",
            "className": "accelerate_info",
            "priority": "M",
            "scanDate": "Thu Feb 29 09:01:09 UTC 2024",
            "fixerCustomMessageText": "In file: <original_filename>, method calc_info a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "fixerCategory": "Inappropriate Logic",
            "selectedNode": "platform1[-4:] == 'i386' or 'intel' in platform1 or \\\n               'x86_64' in platform1 or \\\n               'i386' in platform.platform()",
            "fixNo": "IL-M-97",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <original_filename>, method <span class='function_name'>calc_info</span> a test expression has multiple calls of the same method. This is redundant and affects performance. On the other hand, if this is desired behavior in which multiple method calls with the same parameter returns different results, the logic should be reviewed to distinguish the method calls and make the code clean. iCR suggested that the method calls should be refactored and then the local variable should be used in the test expression.",
            "diffLocations": [
                "system_info.py9452356934102177777.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "readfortrancode",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, method readfortrancode an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception(\n                f'readfortrancode: reading {fin.filename()}#{fin.lineno()}'\n                f' failed with\\n{msg}.\\nIt is likely that installing charset_normalizer'\n                ' package will help f2py determine the input file encoding'\n                ' correctly.')",
            "fixNo": "EH-M-1",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, method <span class='function_name'>readfortrancode</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "crackfortran.py6198674056094642026.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "crackline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, method crackline an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception('crackline: groupcounter(=%s) is nonpositive. '\n                            'Check the blocks.'\n                            % (groupcounter))",
            "fixNo": "EH-M-2",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, method <span class='function_name'>crackline</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "crackfortran.py12124301910311203838.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "postcrack",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, method postcrack an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception('postcrack: Expected block dictionary instead of ' +\n                        str(block))",
            "fixNo": "EH-M-3",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, method <span class='function_name'>postcrack</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "crackfortran.py13597140753852576417.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "appenddecl",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, method appenddecl an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception('appenddecl: Unknown variable definition key: ' +\n                            str(k))",
            "fixNo": "EH-M-4",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, method <span class='function_name'>appenddecl</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "crackfortran.py3436540059452289622.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "readfortrancode",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, method readfortrancode an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception('readfortrancode: Found non-(space,digit) char '\n                                'in the first column.\\n\\tAre you sure that '\n                                'this code is in fix form?\\n\\tline=%s' % repr(l))",
            "fixNo": "EH-M-5",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, method <span class='function_name'>readfortrancode</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "crackfortran.py17952427602002843411.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "crackline",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/f2py/crackfortran.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:26 UTC 2024",
            "fixerCustomMessageText": "In file: crackfortran.py, method crackline an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception('crackline: End group %s does not match with '\n                            'previous Begin group %s\\n\\t%s' %\n                            (repr(m1.group('this')), repr(groupname[groupcounter]),\n                             filepositiontext)\n                            )",
            "fixNo": "EH-M-6",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>crackfortran.py</span>, method <span class='function_name'>crackline</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "crackfortran.py9916536901345026549.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "main",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/tools/check_installed_files.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:02:17 UTC 2024",
            "fixerCustomMessageText": "In file: check_installed_files.py, method main an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception(\"%s is not installed\" % numpy_pyi_files[pyi_file])",
            "fixNo": "EH-M-7",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>check_installed_files.py</span>, method <span class='function_name'>main</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "check_installed_files.py5122935200512933402.diff"
            ]
        },
        {
            "fixerCustomHeading": "Raise Custom Exceptions",
            "isWarning": "True",
            "functionName": "main",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/tools/check_installed_files.py",
            "fixerCategoryTag": "PySEH-3",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:02:17 UTC 2024",
            "fixerCustomMessageText": "In file: check_installed_files.py, method main an {Exception} or a {BaseException} was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for raising exception.",
            "fixerCategory": "Error Handling",
            "selectedNode": "raise Exception(\n                \"%s is not installed\" % numpy_test_files[test_file]\n            )",
            "fixNo": "EH-M-8",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>check_installed_files.py</span>, method <span class='function_name'>main</span> an <span class='key-word'>Exception</span> or a <span class='key-word'>BaseException</span> was raised. This creates confusion since the exceptions are then differentiated only by the messages they carry. iCR suggested that a specific built-in exception or a custom exception is raised. For more information, read the Python guideline for <a href='https://www.python.org/dev/peps/pep-0352/' target='_blank'>raising exception</a>.",
            "diffLocations": [
                "check_installed_files.py5226266880661995867.diff"
            ]
        },
        {
            "fixerCustomHeading": "Validate Dunder All List",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/umath.py",
            "fixerCategoryTag": "PyDAV-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:05 UTC 2024",
            "fixerCustomMessageText": "In file: umath.py, the list named {__all__} contains undefined names which can result in errors when this module is imported. iCR removed the undefined names from the list. For more information regarding {__all__}, please read about importing fields from a package.",
            "fixerCategory": "Security Misconfiguration Issues",
            "selectedNode": "# OpenRefactory Warning:\n# Undefined names in \"__all__\": ERR_CALL, ERR_DEFAULT, ERR_IGNORE, ERR_LOG, ERR_PRINT, ERR_RAISE, ERR_WARN, FLOATING_POINT_SUPPORT, FPE_DIVIDEBYZERO, FPE_INVALID, FPE_OVERFLOW, FPE_UNDERFLOW, NAN, NINF, NZERO, PINF, PZERO, SHIFT_DIVIDEBYZERO, SHIFT_INVALID, SHIFT_OVERFLOW, SHIFT_UNDERFLOW, UFUNC_BUFSIZE_DEFAULT, UFUNC_PYVALS_NAME, absolute, add, arccos, arccosh, arcsin, arcsinh, arctan, arctan2, arctanh, bitwise_and, bitwise_or, bitwise_xor, cbrt, ceil, conj, conjugate, copysign, cos, cosh, deg2rad, degrees, divide, divmod, e, equal, euler_gamma, exp, exp2, expm1, fabs, floor, floor_divide, float_power, fmax, fmin, fmod, frexp, frompyfunc, gcd, geterrobj, greater, greater_equal, heaviside, hypot, invert, isfinite, isinf, isnan, isnat, lcm, ldexp, left_shift, less, less_equal, log, log10, log1p, log2, logaddexp, logaddexp2, logical_and, logical_not, logical_or, logical_xor, maximum, minimum, mod, modf, multiply, negative, nextafter, not_equal, pi, positive, power, rad2deg, radians, reciprocal, remainder, right_shift, rint, seterrobj, sign, signbit, sin, sinh, spacing, sqrt, square, subtract, tan, tanh, true_divide and trunc\n__all__ = ['_UFUNC_API', '_add_newdoc_ufunc']",
            "fixNo": "SMI-M-1",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>umath.py</span>, the list named <span class='key-word'>__all__</span> contains undefined names which can result in errors when this module is imported. iCR removed the undefined names from the list. For more information regarding <span class='key-word'>__all__</span>, please read about <a href='https://docs.python.org/3/tutorial/modules.html#importing-from-a-package' target='_blank'>importing fields from a package</a>.",
            "diffLocations": [
                "umath.py18126325778941464939.diff"
            ]
        },
        {
            "fixerCustomHeading": "Validate Dunder All List",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/multiarray.py",
            "fixerCategoryTag": "PyDAV-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 08:58:16 UTC 2024",
            "fixerCustomMessageText": "In file: multiarray.py, the list named {__all__} contains undefined names which can result in errors when this module is imported. iCR removed the undefined names from the list. For more information regarding {__all__}, please read about importing fields from a package.",
            "fixerCategory": "Security Misconfiguration Issues",
            "selectedNode": "# OpenRefactory Warning:\n# Undefined names in \"__all__\": ALLOW_THREADS, BUFSIZE, CLIP, DATETIMEUNITS, ITEM_HASOBJECT, ITEM_IS_POINTER, LIST_PICKLE, MAXDIMS, MAY_SHARE_BOUNDS, MAY_SHARE_EXACT, NEEDS_INIT, NEEDS_PYAPI, RAISE, USE_GETITEM, USE_SETITEM, WRAP, add_docstring, arange, array, asarray, asanyarray, ascontiguousarray, asfortranarray, broadcast, busdaycalendar, compare_chararrays, correlate, correlate2, count_nonzero, c_einsum, datetime_data, dragon4_positional, dragon4_scientific, dtype, empty, error, flagsobj, flatiter, format_longfloat, frombuffer, fromfile, fromiter, fromstring, get_handler_name, get_handler_version, interp, interp_complex, matmul, ndarray, nditer, nested_iters, normalize_axis_index, promote_types, scalar, set_datetimeparse_function, set_legacy_print_mode, set_numeric_ops, set_string_function, set_typeDict, tracemalloc_domain, typeinfo and zeros\n__all__ = ['_ARRAY_API', '_flagdict', 'from_dlpack', '_place', '_reconstruct', '_vec_string', '_monotonicity', 'bincount', 'busday_count', 'busday_offset', 'can_cast', 'concatenate', 'copyto', 'datetime_as_string', 'dot', 'empty_like', 'inner', 'is_busday', 'lexsort', 'may_share_memory', 'min_scalar_type', 'packbits', 'putmask', 'ravel_multi_index', 'result_type', 'shares_memory', 'unpackbits', 'unravel_index', 'vdot', 'where', '_get_promotion_state', '_set_promotion_state', '_using_numpy2_behavior']",
            "fixNo": "SMI-M-2",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>multiarray.py</span>, the list named <span class='key-word'>__all__</span> contains undefined names which can result in errors when this module is imported. iCR removed the undefined names from the list. For more information regarding <span class='key-word'>__all__</span>, please read about <a href='https://docs.python.org/3/tutorial/modules.html#importing-from-a-package' target='_blank'>importing fields from a package</a>.",
            "diffLocations": [
                "multiarray.py6356565400413187057.diff"
            ]
        },
        {
            "fixerCustomHeading": "Validate Dunder All List",
            "isWarning": "True",
            "functionName": null,
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/random/__init__.py",
            "fixerCategoryTag": "PyDAV-1",
            "className": null,
            "priority": "M",
            "scanDate": "Thu Feb 29 09:00:34 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.py, the list named {__all__} contains undefined names which can result in errors when this module is imported. iCR removed the undefined names from the list. For more information regarding {__all__}, please read about importing fields from a package.",
            "fixerCategory": "Security Misconfiguration Issues",
            "selectedNode": "# OpenRefactory Warning:\n# Undefined names in \"__all__\": beta, binomial, bytes, chisquare, choice, dirichlet, exponential, f, gamma, geometric, get_state, gumbel, hypergeometric, laplace, logistic, lognormal, logseries, multinomial, multivariate_normal, negative_binomial, noncentral_chisquare, noncentral_f, normal, pareto, permutation, poisson, power, rand, randint, randn, random, random_integers, random_sample, ranf, rayleigh, sample, seed, set_state, shuffle, standard_cauchy, standard_exponential, standard_gamma, standard_normal, standard_t, triangular, uniform, vonmises, wald, weibull and zipf\n__all__ = []",
            "fixNo": "SMI-M-3",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.py</span>, the list named <span class='key-word'>__all__</span> contains undefined names which can result in errors when this module is imported. iCR removed the undefined names from the list. For more information regarding <span class='key-word'>__all__</span>, please read about <a href='https://docs.python.org/3/tutorial/modules.html#importing-from-a-package' target='_blank'>importing fields from a package</a>.",
            "diffLocations": [
                "__init__.py16412378887896584359.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/ma/core.py",
            "fixerCategoryTag": "PyARP-2",
            "className": "mvoid",
            "priority": "L",
            "scanDate": "Thu Feb 29 08:57:31 UTC 2024",
            "fixerCustomMessageText": "In file: core.py, class mvoid method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __new__(cls, data, mask=nomask, dtype=None, fill_value=None,\n                hardmask=False, copy=False, subok=True):\n        _data = np.array(data, copy=copy, subok=subok, dtype=dtype)\n        _data = _data.view(cls)\n        _data._hardmask = hardmask\n        if mask is not nomask:\n            if isinstance(mask, np.void):\n                _data._mask = mask\n            else:\n                try:\n                    # Mask is already a 0D array\n                    _data._mask = np.void(mask)\n                except TypeError:\n                    # Transform the mask to a void\n                    mdtype = make_mask_descr(dtype)\n                    _data._mask = np.array(mask, dtype=mdtype)[()]\n        if fill_value is not None:\n            _data.fill_value = fill_value\n        return _data",
            "fixNo": "IMC-L-1",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>core.py</span>, class <span class='class_name'>mvoid</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "core.py8877837684315044333.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/ma/core.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "mvoid",
            "priority": "L",
            "scanDate": "Thu Feb 29 08:57:37 UTC 2024",
            "fixerCustomMessageText": "In file: core.pyi, class mvoid method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __new__(\n        cls,\n        data,\n        mask=...,\n        dtype=...,\n        fill_value=...,\n        hardmask=...,\n        copy=...,\n        subok=...,\n    ): ...",
            "fixNo": "IMC-L-2",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>core.pyi</span>, class <span class='class_name'>mvoid</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "core.pyi8168679018472804259.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/memmap.py",
            "fixerCategoryTag": "PyARP-2",
            "className": "memmap",
            "priority": "L",
            "scanDate": "Thu Feb 29 08:58:06 UTC 2024",
            "fixerCustomMessageText": "In file: memmap.py, class memmap method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __new__(cls, filename, dtype=uint8, mode='r+', offset=0,\n                shape=None, order='C'):\n        # Import here to minimize 'import numpy' overhead\n        import mmap\n        import os.path\n        try:\n            mode = mode_equivalents[mode]\n        except KeyError as e:\n            if mode not in valid_filemodes:\n                raise ValueError(\n                    \"mode must be one of {!r} (got {!r})\"\n                    .format(valid_filemodes + list(mode_equivalents.keys()), mode)\n                ) from None\n\n        if mode == 'w+' and shape is None:\n            raise ValueError(\"shape must be given if mode == 'w+'\")\n\n        if hasattr(filename, 'read'):\n            f_ctx = nullcontext(filename)\n        else:\n            f_ctx = open(os_fspath(filename), ('r' if mode == 'c' else mode)+'b')\n\n        with f_ctx as fid:\n            fid.seek(0, 2)\n            flen = fid.tell()\n            descr = dtypedescr(dtype)\n            _dbytes = descr.itemsize\n\n            if shape is None:\n                bytes = flen - offset\n                if bytes % _dbytes:\n                    raise ValueError(\"Size of available data is not a \"\n                            \"multiple of the data-type size.\")\n                size = bytes // _dbytes\n                shape = (size,)\n            else:\n                if not isinstance(shape, tuple):\n                    shape = (shape,)\n                size = np.intp(1)  # avoid default choice of np.int_, which might overflow\n                for k in shape:\n                    size *= k\n\n            bytes = int(offset + size*_dbytes)\n\n            if mode in ('w+', 'r+') and flen < bytes:\n                fid.seek(bytes - 1, 0)\n                fid.write(b'\\0')\n                fid.flush()\n\n            if mode == 'c':\n                acc = mmap.ACCESS_COPY\n            elif mode == 'r':\n                acc = mmap.ACCESS_READ\n            else:\n                acc = mmap.ACCESS_WRITE\n\n            start = offset - offset % mmap.ALLOCATIONGRANULARITY\n            bytes -= start\n            array_offset = offset - start\n            mm = mmap.mmap(fid.fileno(), bytes, access=acc, offset=start)\n\n            self = ndarray.__new__(cls, shape, dtype=descr, buffer=mm,\n                                   offset=array_offset, order=order)\n            self._mmap = mm\n            self.offset = offset\n            self.mode = mode\n\n            if is_pathlib_path(filename):\n                # special case - if we were constructed with a pathlib.path,\n                # then filename is a path object, not a string\n                self.filename = filename.resolve()\n            elif hasattr(fid, \"name\") and isinstance(fid.name, str):\n                # py3 returns int for TemporaryFile().name\n                self.filename = os.path.abspath(fid.name)\n            # same as memmap copies (e.g. memmap + 1)\n            else:\n                self.filename = None\n\n        return self",
            "fixNo": "IMC-L-3",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>memmap.py</span>, class <span class='class_name'>memmap</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "memmap.py15478577494900185461.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/records.py",
            "fixerCategoryTag": "PyARP-2",
            "className": "recarray",
            "priority": "L",
            "scanDate": "Thu Feb 29 08:58:10 UTC 2024",
            "fixerCustomMessageText": "In file: records.py, class recarray method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __new__(cls, shape, dtype=None, buf=None, offset=0, strides=None,\n                formats=None, names=None, titles=None,\n                byteorder=None, aligned=False, order='C'):\n\n        if dtype is not None:\n            descr = sb.dtype(dtype)\n        else:\n            descr = format_parser(formats, names, titles, aligned, byteorder).dtype\n\n        if buf is None:\n            self = ndarray.__new__(cls, shape, (record, descr), order=order)\n        else:\n            self = ndarray.__new__(cls, shape, (record, descr),\n                                   buffer=buf, offset=offset,\n                                   strides=strides, order=order)\n        return self",
            "fixNo": "IMC-L-4",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>records.py</span>, class <span class='class_name'>recarray</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "records.py12691031255103023106.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/core/defchararray.py",
            "fixerCategoryTag": "PyARP-2",
            "className": "chararray",
            "priority": "L",
            "scanDate": "Thu Feb 29 08:58:30 UTC 2024",
            "fixerCustomMessageText": "In file: defchararray.py, class chararray method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __new__(cls, shape, itemsize=1, unicode=False, buffer=None,\n                offset=0, strides=None, order='C'):\n        global _globalvar\n\n        if unicode:\n            dtype = str_\n        else:\n            dtype = bytes_\n\n        # force itemsize to be a Python int, since using NumPy integer\n        # types results in itemsize.itemsize being used as the size of\n        # strings in the new array.\n        itemsize = int(itemsize)\n\n        if isinstance(buffer, str):\n            # unicode objects do not have the buffer interface\n            filler = buffer\n            buffer = None\n        else:\n            filler = None\n\n        _globalvar = 1\n        if buffer is None:\n            self = ndarray.__new__(cls, shape, (dtype, itemsize),\n                                   order=order)\n        else:\n            self = ndarray.__new__(cls, shape, (dtype, itemsize),\n                                   buffer=buffer,\n                                   offset=offset, strides=strides,\n                                   order=order)\n        if filler is not None:\n            self[...] = filler\n        _globalvar = 0\n        return self",
            "fixNo": "IMC-L-5",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>defchararray.py</span>, class <span class='class_name'>chararray</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "defchararray.py11719441980219535535.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/matrixlib/defmatrix.py",
            "fixerCategoryTag": "PyARP-2",
            "className": "matrix",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:01:21 UTC 2024",
            "fixerCustomMessageText": "In file: defmatrix.py, class matrix method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __new__(cls, data, dtype=None, copy=True):\n        warnings.warn('the matrix subclass is not the recommended way to '\n                      'represent matrices or deal with linear algebra (see '\n                      'https://docs.scipy.org/doc/numpy/user/'\n                      'numpy-for-matlab-users.html). '\n                      'Please adjust your code to use regular ndarray.',\n                      PendingDeprecationWarning, stacklevel=2)\n        if isinstance(data, matrix):\n            dtype2 = data.dtype\n            if (dtype is None):\n                dtype = dtype2\n            if (dtype2 == dtype) and (not copy):\n                return data\n            return data.astype(dtype)\n\n        if isinstance(data, N.ndarray):\n            if dtype is None:\n                intype = data.dtype\n            else:\n                intype = N.dtype(dtype)\n            new = data.view(cls)\n            if intype != data.dtype:\n                return new.astype(intype)\n            if copy: return new.copy()\n            else: return new\n\n        if isinstance(data, str):\n            data = _convert_from_string(data)\n\n        # now convert data to an array\n        arr = N.array(data, dtype=dtype, copy=copy)\n        ndim = arr.ndim\n        shape = arr.shape\n        if (ndim > 2):\n            raise ValueError(\"matrix must be 2-dimensional\")\n        elif ndim == 0:\n            shape = (1, 1)\n        elif ndim == 1:\n            shape = (1, shape[0])\n\n        order = 'C'\n        if (ndim == 2) and arr.flags.fortran:\n            order = 'F'\n\n        if not (order or arr.flags.contiguous):\n            arr = arr.copy()\n\n        ret = N.ndarray.__new__(cls, shape, arr.dtype,\n                                buffer=arr,\n                                order=order)\n        return ret",
            "fixNo": "IMC-L-6",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>defmatrix.py</span>, class <span class='class_name'>matrix</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "defmatrix.py983617481349288797.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__class_getitem__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "number",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class number method __class_getitem__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __class_getitem__(cls, item: Any) -> GenericAlias: ...",
            "fixNo": "IMC-L-7",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>number</span> method <span class='function_name'>__class_getitem__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi3656589781663973562.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "recarray",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class recarray method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "@overload\n    def __new__(\n        cls,\n        shape: _ShapeLike,\n        dtype: DTypeLike,\n        buf: None | _SupportsBuffer = ...,\n        offset: SupportsIndex = ...,\n        strides: None | _ShapeLike = ...,\n        formats: None = ...,\n        names: None = ...,\n        titles: None = ...,\n        byteorder: None = ...,\n        aligned: L[False] = ...,\n        order: _OrderKACF = ...,\n    ) -> recarray[Any, dtype[Any]]: ...",
            "fixNo": "IMC-L-8",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>recarray</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi10843319137982598882.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "chararray",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class chararray method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "@overload\n    def __new__(\n        cls,\n        shape: _ShapeLike,\n        itemsize: SupportsIndex | SupportsInt = ...,\n        unicode: L[True] = ...,\n        buffer: _SupportsBuffer = ...,\n        offset: SupportsIndex = ...,\n        strides: _ShapeLike = ...,\n        order: _OrderKACF = ...,\n    ) -> chararray[Any, dtype[str_]]: ...",
            "fixNo": "IMC-L-9",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>chararray</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi14031306005339481547.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "memmap",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class memmap method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "@overload\n    def __new__(\n        cls,\n        filename: str | bytes | os.PathLike[str] | os.PathLike[bytes] | _MemMapIOProtocol,\n        dtype: _DTypeLike[_ScalarType],\n        mode: _MemMapModeKind = ...,\n        offset: int = ...,\n        shape: None | int | tuple[int, ...] = ...,\n        order: _OrderKACF = ...,\n    ) -> memmap[Any, dtype[_ScalarType]]: ...",
            "fixNo": "IMC-L-10",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>memmap</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi3894978737085019038.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "chararray",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class chararray method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "@overload\n    def __new__(\n        cls,\n        shape: _ShapeLike,\n        itemsize: SupportsIndex | SupportsInt = ...,\n        unicode: L[False] = ...,\n        buffer: _SupportsBuffer = ...,\n        offset: SupportsIndex = ...,\n        strides: _ShapeLike = ...,\n        order: _OrderKACF = ...,\n    ) -> chararray[Any, dtype[bytes_]]: ...",
            "fixNo": "IMC-L-11",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>chararray</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi3774395895095099458.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "memmap",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class memmap method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "@overload\n    def __new__(\n        cls,\n        filename: str | bytes | os.PathLike[str] | os.PathLike[bytes] | _MemMapIOProtocol,\n        dtype: type[uint8] = ...,\n        mode: _MemMapModeKind = ...,\n        offset: int = ...,\n        shape: None | int | tuple[int, ...] = ...,\n        order: _OrderKACF = ...,\n    ) -> memmap[Any, dtype[uint8]]: ...",
            "fixNo": "IMC-L-12",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>memmap</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi9442113792383182179.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "recarray",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class recarray method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "@overload\n    def __new__(\n        cls,\n        shape: _ShapeLike,\n        dtype: None = ...,\n        buf: None | _SupportsBuffer = ...,\n        offset: SupportsIndex = ...,\n        strides: None | _ShapeLike = ...,\n        *,\n        formats: DTypeLike,\n        names: None | str | Sequence[str] = ...,\n        titles: None | str | Sequence[str] = ...,\n        byteorder: None | _ByteOrder = ...,\n        aligned: bool = ...,\n        order: _OrderKACF = ...,\n    ) -> recarray[Any, dtype[record]]: ...",
            "fixNo": "IMC-L-13",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>recarray</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi7351808968510536174.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__class_getitem__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "dtype",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class dtype method __class_getitem__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __class_getitem__(cls, item: Any) -> GenericAlias: ...",
            "fixNo": "IMC-L-14",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>dtype</span> method <span class='function_name'>__class_getitem__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi14148750328843022690.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "matrix",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class matrix method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __new__(\n        cls,\n        data: ArrayLike,\n        dtype: DTypeLike = ...,\n        copy: bool = ...,\n    ) -> matrix[Any, Any]: ...",
            "fixNo": "IMC-L-15",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>matrix</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi6956253149404635181.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__new__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "memmap",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class memmap method __new__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "@overload\n    def __new__(\n        cls,\n        filename: str | bytes | os.PathLike[str] | os.PathLike[bytes] | _MemMapIOProtocol,\n        dtype: DTypeLike,\n        mode: _MemMapModeKind = ...,\n        offset: int = ...,\n        shape: None | int | tuple[int, ...] = ...,\n        order: _OrderKACF = ...,\n    ) -> memmap[Any, dtype[Any]]: ...",
            "fixNo": "IMC-L-16",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>memmap</span> method <span class='function_name'>__new__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi4644423847702052570.diff"
            ]
        },
        {
            "fixerCustomHeading": "Add Required Parameter",
            "isWarning": "False",
            "functionName": "__class_getitem__",
            "projectPath": "/workspace/source/",
            "filePath": "/workspace/source/numpy/__init__.pyi",
            "fixerCategoryTag": "PyARP-2",
            "className": "ndarray",
            "priority": "L",
            "scanDate": "Thu Feb 29 09:02:05 UTC 2024",
            "fixerCustomMessageText": "In file: __init__.pyi, class ndarray method __class_getitem__ does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the Python documentation on methods",
            "fixerCategory": "Improper Method Call",
            "selectedNode": "def __class_getitem__(cls, item: Any) -> GenericAlias: ...",
            "fixNo": "IMC-L-17",
            "relatedSourceLocations": null,
            "fixerCustomMessage": "In file: <span class='original_filename'>__init__.pyi</span>, class <span class='class_name'>ndarray</span> method <span class='function_name'>__class_getitem__</span> does not follow the naming convention for its first parameter. This may be an instance method with the first parameter not called self, or a class method with the first parameter not called cls. iCR identified these and suggested that the parameter name is changed to follow convention. For more information, read the <a href='https://docs.python.org/3.8/tutorial/classes.html#method-objects' target='_blank'>Python documentation on methods</a>",
            "diffLocations": [
                "__init__.pyi16464727996284576503.diff"
            ]
        }
    ]
}